# 单词筛选工具匹配规则技术文档

## 文档概述
本文档详细说明单词筛选工具中的各种匹配规则机制，包括基础规则、组合规则、特殊标记等，并提供完整的使用范例。

## 基础匹配规则

### 1. 字符集合匹配

#### 基本语法
- `[abc]` - 匹配字符a、b或c中的任意一个
- `[a-z]` - 匹配小写字母a到z中的任意一个
- `[A-Z]` - 匹配大写字母A到Z中的任意一个
- `[0-9]` - 匹配数字0到9中的任意一个

#### 组合使用
- `[a-zA-Z]` - 匹配任意字母
- `[a-zA-Z0-9]` - 匹配字母或数字
- `[aeiou]` - 匹配元音字母
- `[bcdfg...]` - 匹配辅音字母

#### 范例
```javascript
// 匹配包含元音字母的单词
{
  name: "包含元音",
  code: "word.includes('[aeiou]')"
}

// 匹配以大写字母开头的单词
{
  name: "首字母大写",
  code: "word[0].match('[A-Z]')"
}
```

### 2. 长度限制规则

#### 基本语法
- `word.length === n` - 精确长度匹配
- `word.length >= n` - 最小长度
- `word.length <= n` - 最大长度
- `word.length >= m && word.length <= n` - 长度范围

#### 范例
```javascript
// 3-5字母单词
{
  name: "中等长度单词",
  code: "word.length >= 3 && word.length <= 5"
}

// 长单词（8字母以上）
{
  name: "长单词",
  code: "word.length >= 8"
}
```

## 位置匹配规则

### 1. \m 标记（中间匹配）
**功能：** 匹配单词中间位置的字符或模式

#### 语法
- `\m[pattern]` - 在单词中间查找指定模式
- `\m{position}[pattern]` - 在指定位置查找模式

#### 实现逻辑
```javascript
// 伪代码实现
function matchMiddle(word, pattern) {
  const middleStart = Math.floor(word.length / 4);
  const middleEnd = Math.ceil(word.length * 3 / 4);
  const middlePart = word.slice(middleStart, middleEnd);
  return middlePart.includes(pattern);
}
```

#### 范例
```javascript
// 中间包含"ing"的单词
{
  name: "中间含ing",
  code: "\\m[ing]"
}

// 结果：running, singing, bringing 等
```

### 2. \-b 标记（词首匹配）
**功能：** 匹配单词开头的字符或模式

#### 语法
- `\-b[pattern]` - 单词必须以指定模式开头
- `\-b{n}[pattern]` - 前n个字符中包含模式

#### 实现逻辑
```javascript
// 伪代码实现
function matchBeginning(word, pattern) {
  return word.startsWith(pattern);
}
```

#### 范例
```javascript
// 以"pre"开头的单词
{
  name: "pre前缀",
  code: "\\-b[pre]"
}

// 结果：prepare, present, previous 等
```

### 3. \-e 标记（词尾匹配）
**功能：** 匹配单词结尾的字符或模式

#### 语法
- `\-e[pattern]` - 单词必须以指定模式结尾
- `\-e{n}[pattern]` - 后n个字符中包含模式

#### 实现逻辑
```javascript
// 伪代码实现
function matchEnding(word, pattern) {
  return word.endsWith(pattern);
}
```

#### 范例
```javascript
// 以"tion"结尾的单词
{
  name: "tion后缀",
  code: "\\-e[tion]"
}

// 结果：information, education, creation 等
```

## 组合规则

### 1. && 操作符（与逻辑）
**功能：** 所有条件都必须满足

#### 语法
```javascript
condition1 && condition2 && condition3
```

#### 范例
```javascript
// 5字母且以"s"开头且以"e"结尾
{
  name: "特定模式",
  code: "word.length === 5 && \\-b[s] && \\-e[e]"
}

// 结果：snake, smile, stone 等
```

### 2. || 操作符（或逻辑）
**功能：** 任意一个条件满足即可

#### 语法
```javascript
condition1 || condition2 || condition3
```

#### 范例
```javascript
// 以"ing"或"ed"结尾
{
  name: "动词形式",
  code: "\\-e[ing] || \\-e[ed]"
}

// 结果：running, walked, singing, played 等
```

### 3. 非模式（建议新增）
**功能：** 满足前面条件但不满足后面条件

#### 建议符号：`--` 或 `^` 或 `~`
推荐使用 `--` 符号，因为：
- 直观易懂（减法概念）
- 不与现有符号冲突
- 易于输入

#### 建议语法
```javascript
condition1 -- condition2
// 等价于：condition1 && !(condition2)
```

#### 范例
```javascript
// 包含元音但不以元音开头
{
  name: "非元音开头但含元音",
  code: "\\m[aeiou] -- \\-b[aeiou]"
}

// 结果：cat, dog, but (排除 apple, orange)
```

## 全局集合定义

### 当前支持的集合
1. **元音集合：** `V = [aeiou]`
2. **辅音集合：** `C = [bcdfghjklmnpqrstvwxyz]`
3. **数字集合：** `N = [0-9]`
4. **字母集合：** `L = [a-zA-Z]`

### 使用方式
```javascript
// 使用全局集合
{
  name: "CVC模式",
  code: "\\-b[C] && \\m[V] && \\-e[C]"
}
```

### 建议扩展集合
```javascript
// 建议新增的全局集合
const GLOBAL_SETS = {
  V: '[aeiou]',           // 元音
  C: '[bcdfg...]',       // 辅音
  N: '[0-9]',           // 数字
  L: '[a-zA-Z]',        // 字母
  S: '[bcdfghjklmnpqrstvwxyz]', // 强辅音
  W: '[lrwy]',          // 弱辅音
  F: '[fvthsz]'         // 摩擦音
};
```

## 高级匹配模式

### 1. 音节模式匹配
```javascript
// CV模式（辅音+元音）
{
  name: "CV模式",
  code: "word.match(/^[bcdfg...][aeiou]/)"
}

// CVC模式（辅音+元音+辅音）
{
  name: "CVC模式",
  code: "word.match(/^[bcdfg...][aeiou][bcdfg...]$/)"
}
```

### 2. 重复模式匹配
```javascript
// 双字母
{
  name: "双字母",
  code: "word.match(/(.)\\1/)"
}

// 三重字母
{
  name: "三重字母",
  code: "word.match(/(.)\\1\\1/)"
}
```

### 3. 复杂组合模式
```javascript
// 长度5-7，包含双元音，不以s结尾
{
  name: "复杂模式",
  code: "(word.length >= 5 && word.length <= 7) && word.match(/[aeiou]{2}/) -- \\-e[s]"
}
```

## 当前局限性分析

### 1. 音标匹配缺失
**问题：** 无法基于音标进行匹配
**影响：** 无法处理发音相关的筛选需求
**建议：** 集成音标数据库，支持音标匹配

### 2. 语义匹配缺失
**问题：** 无法基于词义进行筛选
**影响：** 无法按主题或语义分类
**建议：** 集成词典API或语义标签

### 3. 词性匹配缺失
**问题：** 无法按词性（名词、动词等）筛选
**影响：** 无法满足语法学习需求
**建议：** 集成词性标注功能

### 4. 复杂正则表达式支持有限
**问题：** 当前规则语法相对简单
**影响：** 无法表达复杂的匹配模式
**建议：** 扩展规则语法，支持更多正则特性

## 优化建议

### 1. 性能优化
```javascript
// 建议使用预编译正则表达式
class RuleEngine {
  constructor() {
    this.compiledRules = new Map();
  }
  
  compileRule(ruleCode) {
    if (!this.compiledRules.has(ruleCode)) {
      const regex = this.parseRuleToRegex(ruleCode);
      this.compiledRules.set(ruleCode, regex);
    }
    return this.compiledRules.get(ruleCode);
  }
}
```

### 2. 规则验证
```javascript
// 建议添加规则语法验证
function validateRule(ruleCode) {
  try {
    // 检查语法正确性
    const ast = parseRule(ruleCode);
    return { valid: true, ast };
  } catch (error) {
    return { valid: false, error: error.message };
  }
}
```

### 3. 规则提示系统
```javascript
// 建议添加智能提示
function getRuleSuggestions(partialRule) {
  const suggestions = [
    'word.length >= ',
    '\\-b[',
    '\\-e[',
    '\\m[',
    '[aeiou]',
    '[bcdfg...]'
  ];
  return suggestions.filter(s => s.startsWith(partialRule));
}
```

## 测试用例建议

### 1. 基础功能测试
```javascript
const testCases = [
  {
    rule: "word.length === 3",
    input: ["cat", "dog", "elephant"],
    expected: ["cat", "dog"]
  },
  {
    rule: "\\-b[s]",
    input: ["snake", "cat", "sun"],
    expected: ["snake", "sun"]
  }
];
```

### 2. 边界情况测试
```javascript
const edgeCases = [
  {
    rule: "word.length === 0",
    input: ["", "a"],
    expected: [""]
  },
  {
    rule: "\\-b[]",
    input: ["test"],
    expected: [] // 空模式应该不匹配任何内容
  }
];
```

## 扩展规划

### 短期目标（1-2个版本）
1. 实现非模式操作符
2. 完善全局集合定义
3. 添加规则验证功能
4. 优化性能

### 中期目标（3-5个版本）
1. 集成音标匹配
2. 添加词性标注
3. 支持复杂正则表达式
4. 实现规则智能提示

### 长期目标（6+个版本）
1. 语义匹配功能
2. 机器学习辅助规则生成
3. 多语言支持
4. 云端规则库

## 总结

当前的匹配规则系统已经具备了基础的字符匹配、位置匹配和组合逻辑功能，能够满足大部分单词筛选需求。主要的改进方向包括：

1. **完善组合逻辑**：添加非模式操作符
2. **扩展匹配能力**：支持音标、词性等高级特性
3. **优化用户体验**：添加验证、提示等辅助功能
4. **提升性能**：优化规则编译和执行效率

建议按照优先级逐步实施这些改进，确保系统的稳定性和可用性。