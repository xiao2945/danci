# 规则引擎系统

## 概述

规则引擎系统是单词筛选工具的核心逻辑模块，通过RuleEngine类实现复杂的单词匹配和筛选功能。该系统支持基于集合的模式匹配、集合运算、逻辑组合和多级排序，为用户提供强大而灵活的筛选能力。

## 核心功能架构

### 1. 集合管理系统

#### 1.1 内置集合定义
**基础字符集：**
- **C（辅音集合）**：b,c,d,f,g,h,j,k,l,m,n,p,q,r,s,t,v,w,x,y,z
- **V（元音集合）**：a,e,i,o,u
- **L（字母集合）**：a-z完整字母表

**集合初始化：**
```javascript
loadDefaultSets() {
    this.globalSets.set('C', new Set(['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']));
    this.globalSets.set('V', new Set(['a', 'e', 'i', 'o', 'u']));
    this.globalSets.set('L', new Set(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']));
}
```

#### 1.2 自定义集合支持
**定义语法：**
```
集合名 == 集合内容
示例：BL == bl,br,cl,cr,dr,fl,fr,gl,gr,pl,pr,sl,sp,st,tr
```

**集合运算：**
- **别名定义**：`A == B` （将集合B的内容赋值给A）
- **集合减法**：`A >> B` （A集合减去B集合的差集运算）
- **集合加法**：`A << B` （A集合加上B集合的并集运算）
- **字面值减法**：`A >> {xyz}` （A集合减去字面字符）
- **字面值加法**：`A << {xyz}` （A集合加上字面字符）

**运算示例：**
```
// 定义特殊辅音组合
BL == {bl,br,cl,cr,dr,fl,fr,gl,gr,pl,pr,sc,sk,sl,sm,sn,sp,st,sw,tr,tw}

// 短元音（去掉u）
ShortV == V >> {u}

// 扩展元音（加上y）
ExtV == V << {y}

// 复合集合运算
SpecialC == C >> {q,x} << {ch,sh,th}
```

#### 1.3 集合作用域管理
**全局集合：**
- 跨规则共享
- 持久化存储
- 支持导入导出

**局部集合：**
- 规则内私有
- 优先级高于全局集合
- 支持引用全局集合进行运算

### 2. 规则解析系统

#### 2.1 规则文本结构
**标准格式：**
```
# 规则名称
// 规则注释（可选）
集合定义（可选）
具体规则
排序规则（可选）
```

#### 2.2 规则类型识别
**基础规则：**
- 以`:`开头
- 直接的模式匹配规则
- 支持位置标记和集合引用
- 示例：`\b(BL)(V)` （以双辅音开头后跟元音）

**组合规则：**
- 以`::`开头的逻辑组合
- 支持4种逻辑运算符：`&&`（与）、`||`（或）、`~`（取反）、`!`（差集）
- 只能引用已有的基础规则，不允许嵌套引用组合规则

**逻辑运算符详解：**
- **`&&`（与运算）**：同时满足两个条件，如 `::A&&B`
- **`||`（或运算）**：满足任一条件，如 `::A||B`
- **`~`（取反运算）**：对规则结果取反，如 `::~A`
- **`!`（差集运算）**：满足前者但不满足后者，如 `::A!B`（注意：这是二元运算符，不支持一元操作）

**运算优先级（从高到低）：**
1. `~`（取反，优先级4，右结合）
2. `!`（差集，优先级3，左结合）
3. `&&`（与，优先级2，左结合）
4. `||`（或，优先级1，左结合）

**组合规则示例：**
```
// 简单或运算
::CVC||CVCE

// 复杂组合（解析为 A||(B&&(C!(~D)))）
::A||B&&C!~D

// 使用括号改变优先级
::~(A&&B)
```

### 3. 模式匹配引擎

#### 3.1 位置标记系统
**标记类型：**
- **`\b`**：单词开头位置
- **`\e`**：单词结尾位置
- **`\-b`**：不在开头
- **`\-e`**：不在结尾
- **无标记**：任意位置匹配

**位置标记示例：**
```
:\bV        // 匹配以元音开头的单词
:C\e        // 匹配以辅音结尾的单词
:\bCVC\e    // 匹配完全为CVC模式的单词
:V          // 匹配包含元音的单词（任意位置）
```

**匹配逻辑：**
```
位置检查 → 模式匹配 → 结果验证
```

#### 3.2 模式元素类型
**集合引用：**
- **单字母集合**：直接引用，如 `V`、`C`、`L`
- **多字母集合**：必须用括号，如 `(BL)`、`(ShortV)`
- **集合量词**：`+` 表示一个或多个，如 `V+`、`(BL)+`

**集合引用示例：**
```
:CV+C       // 辅音+一个或多个元音+辅音
:(BL)V      // 双辅音开头+元音
:C(ShortV)C // 辅音+短元音+辅音
```

**字面字符：**
- 格式：`"字符串"`（双引号包围）
- 精确匹配指定字符序列
- 支持多字符匹配

**字面字符示例：**
```
:CVC"e"     // CVC模式后跟字母e
:"tion"\e   // 以tion结尾的单词
:"ch"V      // ch开头后跟元音
```

**混合模式：**
- 集合和字面字符的组合
- 顺序匹配验证
- 支持复杂的音韵模式

**混合模式示例：**
```
:\bC(xL)+"tion"\e  // 辅音开头，中间任意字母，tion结尾
:(BL)"ing"\e        // 双辅音开头，ing结尾
:"pre"V+C          // pre开头，元音，辅音结尾
```

#### 3.3 匹配算法
**单词验证流程：**
```
解析规则模式 → 提取位置要求 → 逐元素匹配 → 位置验证 → 返回结果
```

**匹配策略：**
- 贪婪匹配：优先匹配较长的模式
- 位置约束：严格验证位置要求
- 部分匹配：支持模式的部分匹配

### 4. 逻辑运算系统

#### 4.1 逻辑表达式解析
**支持的运算符：**
- **`&&`**：逻辑与运算（同时满足两个条件）
- **`||`**：逻辑或运算（满足任一条件）
- **`~`**：逻辑取反运算（对规则结果取反）
- **`!`**：差集运算（满足前者但不满足后者，二元运算符）

**运算优先级：**
```
1. ~ （取反，优先级4，右结合）
2. ! （差集，优先级3，左结合）
3. && （与，优先级2，左结合）
4. || （或，优先级1，左结合）
```

**表达式解析示例：**
```
A||B&&C!~D  →  A||(B&&(C!(~D)))
~A~B        →  ~(A~B)
A&&B&&C     →  (A&&B)&&C
~(A&&B)     →  对(A&&B)的结果取反
```

#### 4.2 表达式树构建
**解析流程：**
```
词法分析 → 语法分析 → AST构建 → 优化处理
```

**AST节点类型：**
- **操作符节点**：AND、OR、NOT
- **规则节点**：基础规则引用
- **叶子节点**：具体的匹配条件

#### 4.3 表达式求值
**求值策略：**
- 递归遍历AST
- 短路求值优化
- 缓存中间结果

### 5. 排序策略引擎

#### 5.1 排序规则语法
**宽松排序语法：**
```

@集合名位置标识符  // 位置匹配排序
```

**严格排序语法：**
```
@@集合名位置标识符集合名位置标识符  // 严格排序，有且只有两个排序元素
@@集合名位置标识符!集合名位置标识符 // 带分组开关的严格排序
```

**基础排序（宽松排序之一）示例：**
```
@           // 按首字母正序分组
@-          // 按首字母逆序分组
@!          // 不分组，字母正序
@!-         // 不分组，字母倒序
```

**位置匹配排序语法：**
```
@集合名位置标识符
示例：@V^ （按元音前缀排序）
```

**位置标识符详解：**
- **`^`**：前缀匹配（元素必须出现在单词开头）
- **`$`**：后缀匹配（元素必须出现在单词结尾）
- **`*`**：任意位置（元素可以出现在单词任意位置）
- **`~`**：严格中间（元素必须出现在单词中间，不在首尾）
- **无标识符**：单级排序时默认为前缀匹配，等同于 `^`；多级排序时必须显式表达

**位置匹配示例：**
```
@V^         // 按开头元音分组（等同于@V）
@C$         // 按结尾辅音分组
@V*         // 按包含的元音分组
@V~         // 按中间元音分组（首尾不是元音）
```

#### 5.2 宽松排序支持
**语法格式：**
```
@(排序元素1)(排序元素2)(排序元素3)
最多支持三级排序
```

**分组开关支持：**
```
@排序元素!排序元素    // 分组开关，!后的元素仅用于排序不再分组
@(排序元素1)!(排序元素2)(排序元素3)  // 多级排序中的分组开关
```

**分组开关详解：**
- 最多只能有一个分组开关。
- `!`只能放在排序标志与排序元素或排序元素与排序元素间。（如：`@!-`、`@!A`或`@A!BC`、`@AB!(-C)`）
- 分组开关只是截断分组，并不截断排序。
- 分组开关会截断分组，即分组开关后的树状结构不再展开。

**注意：** 分组开关`!`与组合规则中差集运算符`!`的区别。

**排序元素格式：**
- **单字母集合**：`V^`、`C$`、`-V*`（可选逆序标志）
- **多字母集合**：`(BL^)`、`(-BL)`、`(ShortV*)`
- **逆序标志**：`-` 可放在集合名前，如 `-V^` 或 `(-V^)`

**宽松排序示例：**
```
@(BL^)(V*)(C$)      // 三级：双辅音开头 > 包含元音 > 辅音结尾
@(-BL^)(V*)         // 二级：双辅音开头逆序 > 包含元音正序
@(V^)(C$)           // 二级：元音开头 > 辅音结尾
@A!B                // 按A分组，但B仅用于排序不再分组
```

**匹配条件：**
- 单词必须同时满足所有级别的匹配条件才能被正确分组
- 未满足条件的单词会被放到"其他"分组
- 宽松模式下，不要求各级排序元素紧邻

**排序逻辑：**
```
一级分组 → 二级分组 → 三级分组 → 组内字母排序
```

#### 5.3 严格排序支持
**语法格式：**
```
@@排序元素排序元素    // 严格排序，有且只有两个排序元素
@@排序元素!排序元素   // 带分组开关的严格排序
```

**严格排序特点：**
- 有且只有两个排序元素
- 排序元素如果无显式匹配符，则同于 `*`
- 严格模式下，必须要求两级元素紧邻

**严格排序示例：**
```
@@CV                // 严格辅音-元音结构（紧邻）
@@C^!V*             // 按辅音开头分组，元音仅用于排序
```

#### 5.4 分组标签生成
**标签格式：**
- **单级**：`集合元素` （如："a", "bl", "t"）
- **二级**：`一级标签 > 二级标签` （如："bl > a", "c > e"）
- **三级**：`一级标签 > 二级标签 > 三级标签` （如："bl > a > t"）

**标签生成示例：**
```
// 对于规则 @(BL^)(V*)(C$)
// 单词 "black" 会生成标签："bl > a > k"
// 单词 "tree" 会生成标签："tr > e > e"
```

**排序方式：**
- 分组按集合中元素的定义顺序排列
- 有逆序标志时按逆序排列
- 逆序标志仅影响该级别的分组顺序
- "其他"分组始终排在各组最后
- 组内单词按字母正序排列

**特殊处理：**
- 未匹配单词归入"其他"分组
- 支持逆序排列（-前缀）
- 保持集合元素定义顺序

### 6. 规则验证系统

#### 6.1 语法验证
**验证项目：**
- 规则名称格式检查
- 注释长度限制（60字符）
- 集合定义语法验证
- 引用完整性检查

#### 6.2 语义验证
**检查内容：**
- 集合引用存在性
- 循环引用检测
- 名称冲突检查
- 跨规则引用限制

#### 6.3 错误诊断
**错误类型：**
- 语法错误：格式不正确
- 引用错误：集合或规则不存在
- 逻辑错误：循环引用、冲突定义

### 7. 规则执行引擎

#### 7.1 单词筛选流程
```
规则解析 → 模式编译 → 单词遍历 → 匹配验证 → 结果收集
```

#### 7.2 性能优化
**优化策略：**
- 模式预编译
- 匹配结果缓存
- 早期退出机制
- 批量处理优化

#### 7.3 结果后处理
**处理步骤：**
- 应用排序规则
- 生成分组信息
- 统计结果数据
- 格式化输出

## 规则处理流程图

```
规则文本输入
    ↓
文本解析
    ├── 规则名称提取
    ├── 注释解析
    ├── 集合定义解析
    ├── 具体规则解析
    └── 排序规则解析
    ↓
规则验证
    ├── 语法检查
    ├── 引用验证
    ├── 循环检测
    └── 冲突检查
    ↓
规则编译
    ├── 模式解析
    ├── 逻辑树构建
    ├── 排序策略编译
    └── 优化处理
    ↓
规则执行
    ├── 单词遍历
    ├── 模式匹配
    ├── 逻辑运算
    └── 结果收集
    ↓
结果处理
    ├── 排序应用
    ├── 分组生成
    ├── 统计计算
    └── 格式化输出
```

## 匹配算法详解

### 1. 基础模式匹配
**算法步骤：**
```
1. 解析模式字符串
2. 提取位置标记
3. 识别模式元素类型
4. 构建匹配状态机
5. 执行匹配验证
```

### 2. 集合匹配优化
**优化技术：**
- 按长度排序集合元素（优先匹配长元素）
- 使用哈希表加速查找
- 预编译常用模式

### 3. 位置约束处理
**约束类型：**
- 开头约束：检查匹配位置是否为0
- 结尾约束：检查匹配结束位置是否为单词长度
- 中间约束：确保不在首尾位置

## 完整规则示例

### 1. 基础规则示例

**简单模式匹配：**
```
# 元音开头
// 匹配以元音开头的单词
:\bV
@
```

**完全匹配模式：**
```
# CVC模式
// 匹配辅音-元音-辅音的三字母单词
:\bCVC\e
@-
```

**字面字符匹配：**
```
# CVCE模式
// 匹配辅音-元音-辅音-e的四字母单词
:\bCVC"e"\e
@V*
```

**集合量词使用：**
```
# 多元音单词
// 匹配包含多个元音的单词
:\bCV+C\e
@V~
```

### 2. 集合运算示例

**局部集合定义：**
```
# 特殊辅音组合
BL == {bl,br,cl,cr,dr,fl,fr,gl,gr,pl,pr,sc,sk,sl,sm,sn,sp,st,sw,tr,tw}
ShortV == V << {u}  // 短元音（去掉u）
:\b(BL)(ShortV)
@(BL)
```

**复合集合运算：**
```
# 扩展辅音
ExtC == C >> {ch,sh,th,wh}  // 辅音加上复合辅音
SpecialV == V >> {y} << {u}  // 元音加y减u
:(ExtC)(SpecialV)
@(ExtC^)
```

### 3. 组合规则示例

**简单逻辑组合：**
```
# CVC或CVCE
// 匹配CVC模式或CVCE模式的单词
::CVC||CVCE
@
```

**复杂逻辑组合：**
```
# 复杂音韵规则
// 匹配元音开头但不是CVC模式的单词
::VowelStart!CVC
@V^
```

**取反运算：**
```
# 非元音开头
// 匹配不以元音开头的单词
::~VowelStart
@C^
```

### 4. 多级排序示例

**二级排序：**
```
# 复杂音韵结构
// 先按辅音群开头分组，再按包含元音分组
:\b(BL)
@(BL^)(V*)
```

**三级排序：**
```
# 完整音韵分析
// 按开头辅音群、中间元音、结尾辅音三级分组
:\b(BL)VC
@(BL^)(V*)(C$)
```

**逆序排序：**
```
# 逆序多级
// 第一级逆序，第二级正序
:\b(BL)V
@(-BL^)(V*)
```

### 5. 高级应用示例

**词缀分析：**
```
# 前缀分析
Prefixes == {pre,pro,anti,auto,co,de,dis,en,fore,in,inter,mid,mis,non,over,re,semi,sub,super,trans,un,under}
:\b(Prefixes)
@(Prefixes^)
```

**后缀分析：**
```
# 常见后缀
Suffixes == {ing,ed,er,est,ly,tion,sion,ness,ment,ful,less,able,ible}
:(Suffixes)\e
@(Suffixes$)
```

**复合词分析：**
```
# 复合词模式
CompoundParts == {book,house,work,time,way,day,life,hand,eye,head}
:(CompoundParts)(CompoundParts)
@(CompoundParts^)(CompoundParts$)
```

## 常见错误与使用建议

### 1. 常见语法错误

**集合引用错误：**
```
❌ 错误：:\bvc\e     // 集合名大小写错误
✅ 正确：:\bCVC\e    // 集合名必须大写
```

**多字母集合引用错误：**
```
❌ 错误：:BLV         // 多字母集合未加括号
✅ 正确：:(BL)V       // 多字母集合需要括号
```

**局部集合作用域错误：**
```
❌ 错误：在规则A中定义的局部集合在规则B中使用
✅ 正确：每个规则中单独定义所需的局部集合
```

**逻辑运算符错误：**
```
❌ 错误：::!A         // !是二元差集运算符，不支持一元操作
✅ 正确：::~A         // 使用取反运算符
✅ 正确：::A!B        // 差集运算的正确用法
```

**位置匹配符错误：**
```
❌ 错误：@(V^*)       // 位置匹配符放在括号外
✅ 正确：@(V*)        // 位置匹配符必须放在括号内
```

### 2. 使用建议

**命名规范：**
- 使用有意义的集合名称（如：Vowels而不是X）
- 保持命名一致性
- 避免与内置集合名冲突

**规则组织：**
- 复杂规则建议拆分为多个简单规则
- 使用组合规则连接多个基础规则
- 合理使用注释说明规则用途

**性能考虑：**
- 避免过度复杂的集合运算
- 合理使用位置标志和位置匹配符
- 优先使用具体的位置约束

### 3. 调试技巧

**分步测试：**
- 复杂规则可以分步测试各个组成部分
- 先测试基础规则，再测试组合规则
- 逐步增加复杂度

**结果验证：**
- 通过实际匹配结果验证规则逻辑
- 检查分组标签是否符合预期
- 注意"其他"分组中的单词

**错误排查：**
- 检查集合引用是否正确
- 验证逻辑运算符优先级
- 确认位置匹配符使用正确

该系统为用户提供了强大而灵活的单词筛选能力，通过直观的规则语法和丰富的功能组合，能够满足从简单的字母匹配到复杂的音韵分析等各种需求。