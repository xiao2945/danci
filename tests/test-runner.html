<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯ç­›é€‰å·¥å…· - å•å…ƒæµ‹è¯•è¿è¡Œå™¨</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: #2563eb;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        .controls {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
        }

        .btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 14px;
        }

        .btn:hover {
            background: #2563eb;
        }

        .btn.success {
            background: #10b981;
        }

        .btn.danger {
            background: #ef4444;
        }

        .results {
            padding: 20px;
        }

        .test-suite {
            margin-bottom: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            overflow: hidden;
        }

        .suite-header {
            background: #f3f4f6;
            padding: 15px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .suite-header:hover {
            background: #e5e7eb;
        }

        .suite-content {
            display: none;
            padding: 15px;
        }

        .suite-content.expanded {
            display: block;
        }

        .test-case {
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .test-case:last-child {
            border-bottom: none;
        }

        .test-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .test-status.pass {
            background: #dcfce7;
            color: #166534;
        }

        .test-status.fail {
            background: #fef2f2;
            color: #dc2626;
        }

        .test-status.pending {
            background: #fef3c7;
            color: #d97706;
        }

        .summary {
            background: #f9fafb;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .summary-item {
            display: inline-block;
            margin-right: 20px;
            font-weight: bold;
        }

        .error-details {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #dc2626;
        }

        .console-output {
            background: #1f2937;
            color: #f9fafb;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .module-selector {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            background: #f0f9ff;
        }

        .module-selector h3 {
            margin: 0 0 15px 0;
            color: #1e40af;
        }

        .module-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .module-btn {
            background: #1e40af;
            font-size: 12px;
            padding: 8px 16px;
        }

        .module-btn:hover {
            background: #1d4ed8;
        }

        .test-input-output {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
        }

        .test-input {
            background: #ecfdf5;
            border-left: 4px solid #10b981;
            padding: 8px;
            margin-bottom: 5px;
        }

        .test-output {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 8px;
        }

        .test-expected {
            background: #dbeafe;
            border-left: 4px solid #3b82f6;
            padding: 8px;
            margin-top: 5px;
        }

        .test-actual {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
            padding: 8px;
            margin-top: 5px;
        }

        .module-stats {
            display: inline-block;
            margin-left: 10px;
            font-size: 12px;
            color: #6b7280;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§ª å•è¯ç­›é€‰å·¥å…· - è‡ªåŠ¨åŒ–æµ‹è¯•ç³»ç»Ÿ</h1>
            <p>åŸºäºåŠŸèƒ½æ–‡æ¡£çš„å…¨é¢æµ‹è¯•è¦†ç›– | å¯è§†åŒ–è¾“å…¥è¾“å‡ºå±•ç¤º</p>
        </div>

        <div class="controls">
            <button class="btn" onclick="runAllTests()">ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
            <button class="btn" onclick="runByModule()">ğŸ“‹ æŒ‰æ¨¡å—è¿è¡Œ</button>
            <button class="btn success" onclick="runPassingTests()">âœ… è¿è¡Œé€šè¿‡çš„æµ‹è¯•</button>
            <button class="btn danger" onclick="runFailingTests()">âŒ è¿è¡Œå¤±è´¥çš„æµ‹è¯•</button>
            <button class="btn" onclick="clearResults()">ğŸ—‘ï¸ æ¸…ç©ºç»“æœ</button>
            <button class="btn" onclick="showTestInputOutput()">ğŸ‘ï¸ æ˜¾ç¤ºè¾“å…¥è¾“å‡º</button>
        </div>

        <div class="module-selector" id="module-selector" style="display: none;">
            <h3>é€‰æ‹©æµ‹è¯•æ¨¡å—ï¼š</h3>
            <div class="module-buttons">
                <button class="btn module-btn" onclick="runModuleTests('ruleEngine')">é«˜çº§è§„åˆ™å¼•æ“ç³»ç»Ÿ</button>
                <button class="btn module-btn" onclick="runModuleTests('resultDisplay')">æ™ºèƒ½ç»“æœå±•ç¤ºç³»ç»Ÿ</button>
                <button class="btn module-btn" onclick="runModuleTests('ruleManager')">å¯è§†åŒ–è§„åˆ™ç®¡ç†ä¸­å¿ƒ</button>
                <button class="btn module-btn" onclick="runModuleTests('fileProcessor')">æ™ºèƒ½æ–‡ä»¶å¤„ç†ç³»ç»Ÿ</button>
                <button class="btn module-btn" onclick="runModuleTests('dataSync')">æ•°æ®æŒä¹…åŒ–ä¸åŒæ­¥ç³»ç»Ÿ</button>
                <button class="btn module-btn" onclick="runModuleTests('integration')">é›†æˆæµ‹è¯•</button>
            </div>
        </div>

        <div class="results">
            <div class="summary" id="summary" style="display: none;">
                <div class="summary-item">æ€»è®¡: <span id="total-tests">0</span></div>
                <div class="summary-item">é€šè¿‡: <span id="passed-tests">0</span></div>
                <div class="summary-item">å¤±è´¥: <span id="failed-tests">0</span></div>
                <div class="summary-item">è·³è¿‡: <span id="skipped-tests">0</span></div>
                <div class="summary-item">è€—æ—¶: <span id="execution-time">0ms</span></div>
            </div>

            <div id="test-results"></div>

            <div class="console-output" id="console-output" style="display: none;">
                <div style="margin-bottom: 10px; font-weight: bold;">ğŸ“‹ æ§åˆ¶å°è¾“å‡º:</div>
                <div id="console-content"></div>
            </div>
        </div>
    </div>

    <!-- åŠ è½½æ ¸å¿ƒç±» -->
    <script src="js/fileUtils.js"></script>
    <script src="js/ruleEngine.js"></script>
    <script src="js/fileStorage.js"></script>
    <script src="js/app.js"></script>

    <!-- ç®€åŒ–çš„æµ‹è¯•æ¡†æ¶ -->
    <script>
        // å¢å¼ºçš„æµ‹è¯•æ¡†æ¶
        class EnhancedTestFramework {
            constructor() {
                this.suites = [];
                this.currentSuite = null;
                this.results = {
                    total: 0,
                    passed: 0,
                    failed: 0,
                    skipped: 0
                };
                this.consoleOutput = [];
                this.startTime = 0;
                this.showInputOutput = false;
                this.moduleStats = new Map();
            }

            describe(name, fn, module = 'general') {
                this.currentSuite = {
                    name: name,
                    module: module,
                    tests: [],
                    beforeEach: null,
                    afterEach: null
                };
                fn();
                this.suites.push(this.currentSuite);
                this.currentSuite = null;
            }

            test(name, fn, testData = null) {
                if (!this.currentSuite) {
                    throw new Error('test() must be called within describe()');
                }
                this.currentSuite.tests.push({
                    name: name,
                    fn: fn,
                    testData: testData,
                    status: 'pending',
                    error: null,
                    duration: 0,
                    input: null,
                    output: null,
                    expected: null
                });
            }

            beforeEach(fn) {
                if (this.currentSuite) {
                    this.currentSuite.beforeEach = fn;
                }
            }

            afterEach(fn) {
                if (this.currentSuite) {
                    this.currentSuite.afterEach = fn;
                }
            }

            expect(actual) {
                return new Expectation(actual);
            }

            async runAllTests() {
                this.startTime = Date.now();
                this.results = { total: 0, passed: 0, failed: 0, skipped: 0 };
                this.consoleOutput = [];
                this.moduleStats.clear();

                for (const suite of this.suites) {
                    await this.runSuite(suite);
                }

                this.displayResults();
            }

            async runModuleTests(module) {
                this.startTime = Date.now();
                this.results = { total: 0, passed: 0, failed: 0, skipped: 0 };
                this.consoleOutput = [];
                this.moduleStats.clear();

                const moduleSuites = this.suites.filter(suite => suite.module === module);

                if (moduleSuites.length === 0) {
                    this.consoleOutput.push(`âš ï¸ æœªæ‰¾åˆ°æ¨¡å— "${module}" çš„æµ‹è¯•ç”¨ä¾‹`);
                    this.displayResults();
                    return;
                }

                for (const suite of moduleSuites) {
                    await this.runSuite(suite);
                }

                this.displayResults();
            }

            async runSuite(suite) {
                // åˆå§‹åŒ–æ¨¡å—ç»Ÿè®¡
                if (!this.moduleStats.has(suite.module)) {
                    this.moduleStats.set(suite.module, { total: 0, passed: 0, failed: 0 });
                }
                const moduleStats = this.moduleStats.get(suite.module);

                for (const test of suite.tests) {
                    this.results.total++;
                    moduleStats.total++;
                    const testStart = Date.now();

                    try {
                        // è¿è¡Œ beforeEach
                        if (suite.beforeEach) {
                            await suite.beforeEach();
                        }

                        // è®°å½•æµ‹è¯•è¾“å…¥
                        if (test.testData) {
                            test.input = test.testData.input;
                            test.expected = test.testData.expected;
                        }

                        // è¿è¡Œæµ‹è¯•
                        const result = await test.fn();
                        test.output = result;
                        test.status = 'pass';
                        this.results.passed++;
                        moduleStats.passed++;
                    } catch (error) {
                        test.status = 'fail';
                        test.error = error;
                        this.results.failed++;
                        moduleStats.failed++;
                        this.consoleOutput.push(`âŒ ${suite.name} > ${test.name}: ${error.message}`);
                    } finally {
                        test.duration = Date.now() - testStart;

                        // è¿è¡Œ afterEach
                        if (suite.afterEach) {
                            try {
                                await suite.afterEach();
                            } catch (error) {
                                this.consoleOutput.push(`âš ï¸ afterEach error: ${error.message}`);
                            }
                        }
                    }
                }
            }

            displayResults() {
                const totalTime = Date.now() - this.startTime;

                // æ›´æ–°æ‘˜è¦
                document.getElementById('summary').style.display = 'block';
                document.getElementById('total-tests').textContent = this.results.total;
                document.getElementById('passed-tests').textContent = this.results.passed;
                document.getElementById('failed-tests').textContent = this.results.failed;
                document.getElementById('skipped-tests').textContent = this.results.skipped;
                document.getElementById('execution-time').textContent = totalTime + 'ms';

                // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
                const resultsContainer = document.getElementById('test-results');
                resultsContainer.innerHTML = '';

                this.suites.forEach(suite => {
                    const suiteElement = this.createSuiteElement(suite);
                    resultsContainer.appendChild(suiteElement);
                });

                // æ˜¾ç¤ºæ§åˆ¶å°è¾“å‡º
                if (this.consoleOutput.length > 0) {
                    document.getElementById('console-output').style.display = 'block';
                    document.getElementById('console-content').innerHTML = this.consoleOutput.join('<br>');
                }
            }

            createSuiteElement(suite) {
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'test-suite';

                const passedCount = suite.tests.filter(t => t.status === 'pass').length;
                const failedCount = suite.tests.filter(t => t.status === 'fail').length;
                const statusText = failedCount > 0 ? `âŒ ${failedCount} failed` : `âœ… ${passedCount} passed`;

                suiteDiv.innerHTML = `
                    <div class="suite-header" onclick="toggleSuite(this)">
                        <span>${suite.name}</span>
                        <span>${statusText} (${suite.tests.length} total)</span>
                    </div>
                    <div class="suite-content">
                        ${suite.tests.map(test => this.createTestElement(test)).join('')}
                    </div>
                `;

                return suiteDiv;
            }

            createTestElement(test) {
                const statusClass = test.status === 'pass' ? 'pass' : test.status === 'fail' ? 'fail' : 'pending';
                const statusIcon = test.status === 'pass' ? 'âœ…' : test.status === 'fail' ? 'âŒ' : 'â³';

                let errorDetails = '';
                if (test.error) {
                    errorDetails = `<div class="error-details">${test.error.message}<br><small>${test.error.stack}</small></div>`;
                }

                let inputOutputDetails = '';
                if (this.showInputOutput && (test.input || test.output || test.expected)) {
                    inputOutputDetails = '<div class="test-input-output">';

                    if (test.input !== null) {
                        inputOutputDetails += `<div class="test-input"><strong>è¾“å…¥:</strong> ${JSON.stringify(test.input)}</div>`;
                    }

                    if (test.expected !== null) {
                        inputOutputDetails += `<div class="test-expected"><strong>æœŸæœ›:</strong> ${JSON.stringify(test.expected)}</div>`;
                    }

                    if (test.output !== null) {
                        inputOutputDetails += `<div class="test-output"><strong>è¾“å‡º:</strong> ${JSON.stringify(test.output)}</div>`;
                    }

                    if (test.status === 'fail' && test.output !== null && test.expected !== null) {
                        inputOutputDetails += `<div class="test-actual"><strong>å®é™…ç»“æœ:</strong> ${JSON.stringify(test.output)}</div>`;
                    }

                    inputOutputDetails += '</div>';
                }

                return `
                    <div class="test-case">
                        <div>
                            <span>${statusIcon} ${test.name}</span>
                            ${errorDetails}
                            ${inputOutputDetails}
                        </div>
                        <div>
                            <span class="test-status ${statusClass}">${test.status.toUpperCase()}</span>
                            <small style="margin-left: 10px; color: #6b7280;">${test.duration}ms</small>
                        </div>
                    </div>
                `;
            }
        }

        // æœŸæœ›ç±»
        class Expectation {
            constructor(actual) {
                this.actual = actual;
            }

            toBe(expected) {
                if (this.actual !== expected) {
                    throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(this.actual)}`);
                }
            }

            toEqual(expected) {
                if (JSON.stringify(this.actual) !== JSON.stringify(expected)) {
                    throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(this.actual)}`);
                }
            }

            toBeDefined() {
                if (this.actual === undefined) {
                    throw new Error('Expected value to be defined');
                }
            }

            toBeNull() {
                if (this.actual !== null) {
                    throw new Error(`Expected null, but got ${JSON.stringify(this.actual)}`);
                }
            }

            toContain(expected) {
                if (!this.actual.includes(expected)) {
                    throw new Error(`Expected ${JSON.stringify(this.actual)} to contain ${JSON.stringify(expected)}`);
                }
            }

            toThrow() {
                try {
                    this.actual();
                    throw new Error('Expected function to throw an error');
                } catch (error) {
                    // æœŸæœ›çš„è¡Œä¸º
                }
            }

            toBeGreaterThan(expected) {
                if (this.actual <= expected) {
                    throw new Error(`Expected ${this.actual} to be greater than ${expected}`);
                }
            }

            toBeLessThan(expected) {
                if (this.actual >= expected) {
                    throw new Error(`Expected ${this.actual} to be less than ${expected}`);
                }
            }
        }

        // å…¨å±€æµ‹è¯•æ¡†æ¶å®ä¾‹
        const testFramework = new EnhancedTestFramework();
        const describe = testFramework.describe.bind(testFramework);
        const test = testFramework.test.bind(testFramework);
        const beforeEach = testFramework.beforeEach.bind(testFramework);
        const afterEach = testFramework.afterEach.bind(testFramework);
        const expect = testFramework.expect.bind(testFramework);

        // æ§åˆ¶å‡½æ•°
        function runAllTests() {
            testFramework.runAllTests();
        }

        function runByModule() {
            const selector = document.getElementById('module-selector');
            selector.style.display = selector.style.display === 'none' ? 'block' : 'none';
        }

        function runModuleTests(module) {
            testFramework.runModuleTests(module);
            document.getElementById('module-selector').style.display = 'none';
        }

        function runPassingTests() {
            // ç®€åŒ–å®ç°ï¼šè¿è¡Œæ‰€æœ‰æµ‹è¯•
            testFramework.runAllTests();
        }

        function runFailingTests() {
            // ç®€åŒ–å®ç°ï¼šè¿è¡Œæ‰€æœ‰æµ‹è¯•
            testFramework.runAllTests();
        }

        function showTestInputOutput() {
            testFramework.showInputOutput = !testFramework.showInputOutput;
            const btn = event.target;
            btn.textContent = testFramework.showInputOutput ? 'ğŸ™ˆ éšè—è¾“å…¥è¾“å‡º' : 'ğŸ‘ï¸ æ˜¾ç¤ºè¾“å…¥è¾“å‡º';
            // é‡æ–°æ˜¾ç¤ºç»“æœ
            testFramework.displayResults();
        }

        function clearResults() {
            document.getElementById('test-results').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            document.getElementById('console-output').style.display = 'none';
        }

        function toggleSuite(header) {
            const content = header.nextElementSibling;
            content.classList.toggle('expanded');
        }

        // æ¨¡æ‹Ÿ localStorage
        const mockLocalStorage = {
            data: {},
            getItem(key) {
                return this.data[key] || null;
            },
            setItem(key, value) {
                this.data[key] = value;
            },
            removeItem(key) {
                delete this.data[key];
            },
            clear() {
                this.data = {};
            }
        };

        // å¦‚æœæ²¡æœ‰ localStorageï¼Œä½¿ç”¨æ¨¡æ‹Ÿç‰ˆæœ¬
        if (typeof localStorage === 'undefined') {
            window.localStorage = mockLocalStorage;
        }
    </script>

    <!-- ç®€åŒ–çš„æµ‹è¯•ç”¨ä¾‹ -->
    <script>
        // ==================== é«˜çº§è§„åˆ™å¼•æ“ç³»ç»Ÿæµ‹è¯• ====================

        // 1. é›†åˆå®šä¹‰ä¸å¼•ç”¨æµ‹è¯•
        describe('é›†åˆå®šä¹‰ä¸å¼•ç”¨', () => {
            let ruleEngine;

            beforeEach(() => {
                ruleEngine = new RuleEngine();
            });

            test('åŸºç¡€é›†åˆå®šä¹‰ - å•å­—æ¯é›†åˆ', () => {
                const input = 'V = {a, e, i, o, u}';
                const result = ruleEngine.parseSetDefinition ? ruleEngine.parseSetDefinition(input) : null;
                return result;
            }, {
                input: 'V = {a, e, i, o, u}',
                expected: { name: 'V', elements: ['a', 'e', 'i', 'o', 'u'] }
            });

            test('åŸºç¡€é›†åˆå®šä¹‰ - å¤šå­—æ¯é›†åˆ', () => {
                const input = 'BL = {bl, br, cl, cr, dr}';
                const result = ruleEngine.parseSetDefinition ? ruleEngine.parseSetDefinition(input) : null;
                return result;
            }, {
                input: 'BL = {bl, br, cl, cr, dr}',
                expected: { name: 'BL', elements: ['bl', 'br', 'cl', 'cr', 'dr'] }
            });

            test('é›†åˆå¼•ç”¨éªŒè¯', () => {
                const input = '@V';
                const result = ruleEngine.validateSetReference ? ruleEngine.validateSetReference(input) : true;
                return result;
            }, {
                input: '@V',
                expected: true
            });

            test('æœªå®šä¹‰é›†åˆå¼•ç”¨æ£€æµ‹', () => {
                try {
                    const input = '@UNDEFINED';
                    ruleEngine.validateSetReference ? ruleEngine.validateSetReference(input) : null;
                    return false;
                } catch (error) {
                    return error.message.includes('æœªå®šä¹‰');
                }
            }, {
                input: '@UNDEFINED',
                expected: true
            });
        }, 'ruleEngine');

        // 2. è§„åˆ™è¯­æ³•è§£ææµ‹è¯•
        describe('è§„åˆ™è¯­æ³•è§£æ', () => {
            let ruleEngine;

            beforeEach(() => {
                ruleEngine = new RuleEngine();
            });

            test('åŸºç¡€è§„åˆ™è§£æ', () => {
                const input = '#æµ‹è¯•è§„åˆ™\n:L=5';
                const result = ruleEngine.parseRule(input);
                expect(result.name).toBe('æµ‹è¯•è§„åˆ™');
                expect(result.specificRule).toBe(':L=5');
                return result;
            }, {
                input: '#æµ‹è¯•è§„åˆ™\n:L=5',
                expected: { name: 'æµ‹è¯•è§„åˆ™', specificRule: ':L=5' }
            });

            test('å¸¦æ³¨é‡Šçš„è§„åˆ™è§£æ', () => {
                const input = '#æµ‹è¯•è§„åˆ™\n// è¿™æ˜¯æµ‹è¯•æ³¨é‡Š\n:L>=3';
                const result = ruleEngine.parseRule(input);
                expect(result.name).toBe('æµ‹è¯•è§„åˆ™');
                expect(result.comment).toBe('è¿™æ˜¯æµ‹è¯•æ³¨é‡Š');
                return result;
            }, {
                input: '#æµ‹è¯•è§„åˆ™\n// è¿™æ˜¯æµ‹è¯•æ³¨é‡Š\n:L>=3',
                expected: { name: 'æµ‹è¯•è§„åˆ™', comment: 'è¿™æ˜¯æµ‹è¯•æ³¨é‡Š' }
            });

            test('å¤æ‚è§„åˆ™è§£æ', () => {
                const input = '#å¤æ‚è§„åˆ™\nVowels=={a,e,i}\n:Vowels>=2';
                const result = ruleEngine.parseRule(input);
                expect(result.name).toBe('å¤æ‚è§„åˆ™');
                expect(result.localSets.has('Vowels')).toBe(true);
                return result;
            }, {
                input: '#å¤æ‚è§„åˆ™\nVowels=={a,e,i}\n:Vowels>=2',
                expected: { name: 'å¤æ‚è§„åˆ™', hasLocalSets: true }
            });

            test('ç©ºè§„åˆ™æ£€æµ‹', () => {
                try {
                    const input = '#ç©ºè§„åˆ™';
                    ruleEngine.parseRule(input);
                    return false;
                } catch (error) {
                    return error.message.includes('å…·ä½“è§„åˆ™ä¸èƒ½ä¸ºç©º');
                }
            }, {
                input: '#ç©ºè§„åˆ™',
                expected: true
            });
        }, 'ruleEngine');

        // 3. æ¨¡å¼åŒ¹é…å¼•æ“æµ‹è¯•
        describe('æ¨¡å¼åŒ¹é…å¼•æ“', () => {
            let ruleEngine;

            beforeEach(() => {
                ruleEngine = new RuleEngine();
            });

            test('ä½ç½®åŒ¹é… - å‰ç¼€', () => {
                const rule = ruleEngine.parseRule('#å‰ç¼€è§„åˆ™\n^[ptk]');
                const words = ['pat', 'cat', 'bat', 'top'];
                const results = words.map(word => ruleEngine.matchesRule(word, rule));
                return results;
            }, {
                input: ['pat', 'cat', 'bat', 'top'],
                expected: [true, false, false, true]
            });

            test('ä½ç½®åŒ¹é… - åç¼€', () => {
                const rule = ruleEngine.parseRule('#åç¼€è§„åˆ™\n[nt]$');
                const words = ['cat', 'want', 'dog', 'sent'];
                const results = words.map(word => ruleEngine.matchesRule(word, rule));
                return results;
            }, {
                input: ['cat', 'want', 'dog', 'sent'],
                expected: [false, true, false, true]
            });

            test('æ•°é‡åŒ¹é…', () => {
                const rule = ruleEngine.parseRule('#æ•°é‡è§„åˆ™\n:V>=2');
                const words = ['cat', 'beautiful', 'dog', 'education'];
                const results = words.map(word => ruleEngine.matchesRule(word, rule));
                return results;
            }, {
                input: ['cat', 'beautiful', 'dog', 'education'],
                expected: [false, true, false, true]
            });
        }, 'ruleEngine');

        // ==================== æ™ºèƒ½ç»“æœå±•ç¤ºç³»ç»Ÿæµ‹è¯• ====================

        // 1. å¤šç»´åº¦ç»“æœå±•ç¤ºæµ‹è¯•
        describe('å¤šç»´åº¦ç»“æœå±•ç¤º', () => {
            let displaySystem;

            beforeEach(() => {
                displaySystem = window.DisplaySystem || {
                    groupByFirstLetter: (words) => {
                        const groups = {};
                        words.forEach(word => {
                            const firstLetter = word.charAt(0).toUpperCase();
                            if (!groups[firstLetter]) groups[firstLetter] = [];
                            groups[firstLetter].push(word);
                        });
                        return groups;
                    },
                    groupByLength: (words) => {
                        const groups = {};
                        words.forEach(word => {
                            const length = word.length;
                            if (!groups[length]) groups[length] = [];
                            groups[length].push(word);
                        });
                        return groups;
                    }
                };
            });

            test('æŒ‰é¦–å­—æ¯åˆ†ç»„ - åŸºç¡€åŠŸèƒ½', () => {
                const words = ['apple', 'banana', 'cat', 'dog', 'elephant'];
                const result = displaySystem.groupByFirstLetter(words);
                return result;
            }, {
                input: ['apple', 'banana', 'cat', 'dog', 'elephant'],
                expected: { A: ['apple'], B: ['banana'], C: ['cat'], D: ['dog'], E: ['elephant'] }
            });

            test('æŒ‰é¦–å­—æ¯åˆ†ç»„ - å¤§å°å†™æ··åˆ', () => {
                const words = ['Apple', 'apple', 'BANANA', 'banana'];
                const result = displaySystem.groupByFirstLetter(words);
                return result;
            }, {
                input: ['Apple', 'apple', 'BANANA', 'banana'],
                expected: { A: ['Apple', 'apple'], B: ['BANANA', 'banana'] }
            });

            test('æŒ‰é•¿åº¦åˆ†ç»„', () => {
                const words = ['cat', 'dog', 'apple', 'banana', 'elephant'];
                const result = displaySystem.groupByLength(words);
                return result;
            }, {
                input: ['cat', 'dog', 'apple', 'banana', 'elephant'],
                expected: { 3: ['cat', 'dog'], 5: ['apple'], 6: ['banana'], 8: ['elephant'] }
            });
        }, 'displaySystem');

        // 2. æ™ºèƒ½æ’åºç³»ç»Ÿæµ‹è¯•
        describe('æ™ºèƒ½æ’åºç³»ç»Ÿ', () => {
            let sortSystem;

            beforeEach(() => {
                sortSystem = window.SortSystem || {
                    sortByAlphabet: (words) => [...words].sort(),
                    sortByLength: (words) => [...words].sort((a, b) => a.length - b.length),
                    sortByFrequency: (words, frequencies) => {
                        return [...words].sort((a, b) => (frequencies[b] || 0) - (frequencies[a] || 0));
                    }
                };
            });

            test('å­—æ¯æ’åº', () => {
                const words = ['zebra', 'apple', 'banana', 'cat'];
                const result = sortSystem.sortByAlphabet(words);
                return result;
            }, {
                input: ['zebra', 'apple', 'banana', 'cat'],
                expected: ['apple', 'banana', 'cat', 'zebra']
            });

            test('é•¿åº¦æ’åº', () => {
                const words = ['elephant', 'cat', 'banana', 'dog'];
                const result = sortSystem.sortByLength(words);
                return result;
            }, {
                input: ['elephant', 'cat', 'banana', 'dog'],
                expected: ['cat', 'dog', 'banana', 'elephant']
            });

            test('é¢‘ç‡æ’åº', () => {
                const words = ['apple', 'banana', 'cat'];
                const frequencies = { apple: 5, banana: 3, cat: 8 };
                const result = sortSystem.sortByFrequency(words, frequencies);
                return result;
            }, {
                input: { words: ['apple', 'banana', 'cat'], frequencies: { apple: 5, banana: 3, cat: 8 } },
                expected: ['cat', 'apple', 'banana']
            });
        }, 'displaySystem');

        // ==================== å¯è§†åŒ–è§„åˆ™ç®¡ç†ä¸­å¿ƒæµ‹è¯• ====================

        // 1. åŒé¢æ¿è®¾è®¡æµ‹è¯•
        describe('åŒé¢æ¿è®¾è®¡', () => {
            let panelManager;

            beforeEach(() => {
                panelManager = window.PanelManager || {
                    createPanels: () => ({ left: 'rules', right: 'results' }),
                    resizePanels: (leftWidth, rightWidth) => ({ leftWidth, rightWidth }),
                    togglePanel: (panel) => ({ panel, visible: true })
                };
            });

            test('é¢æ¿å¸ƒå±€åˆ›å»º', () => {
                const result = panelManager.createPanels();
                return result;
            }, {
                input: 'createPanels()',
                expected: { left: 'rules', right: 'results' }
            });

            test('é¢æ¿å¤§å°è°ƒæ•´', () => {
                const result = panelManager.resizePanels(60, 40);
                return result;
            }, {
                input: { leftWidth: 60, rightWidth: 40 },
                expected: { leftWidth: 60, rightWidth: 40 }
            });
        }, 'panelManager');

        // 2. ç¤ºä¾‹åº“ç³»ç»Ÿæµ‹è¯•
        describe('ç¤ºä¾‹åº“ç³»ç»Ÿ', () => {
            let exampleLibrary;

            beforeEach(() => {
                exampleLibrary = window.ExampleLibrary || {
                    getExamplesByCategory: (category) => {
                        const examples = {
                            'åŸºç¡€è§„åˆ™': ['#é•¿åº¦è§„åˆ™\n:L=5', '#å…ƒéŸ³è§„åˆ™\n:V>=2'],
                            'é«˜çº§è§„åˆ™': ['#å¤æ‚è§„åˆ™\nVowels=={a,e,i}\n:Vowels>=2']
                        };
                        return examples[category] || [];
                    },
                    searchExamples: (keyword) => {
                        const allExamples = ['#é•¿åº¦è§„åˆ™\n:L=5', '#å…ƒéŸ³è§„åˆ™\n:V>=2'];
                        return allExamples.filter(ex => ex.includes(keyword));
                    }
                };
            });

            test('æŒ‰åˆ†ç±»è·å–ç¤ºä¾‹', () => {
                const result = exampleLibrary.getExamplesByCategory('åŸºç¡€è§„åˆ™');
                return result;
            }, {
                input: 'åŸºç¡€è§„åˆ™',
                expected: ['#é•¿åº¦è§„åˆ™\n:L=5', '#å…ƒéŸ³è§„åˆ™\n:V>=2']
            });

            test('ç¤ºä¾‹æœç´¢', () => {
                const result = exampleLibrary.searchExamples('é•¿åº¦');
                return result;
            }, {
                input: 'é•¿åº¦',
                expected: ['#é•¿åº¦è§„åˆ™\n:L=5']
            });
        }, 'exampleLibrary');

        // ==================== æ™ºèƒ½æ–‡ä»¶å¤„ç†ç³»ç»Ÿæµ‹è¯• ====================

        // 1. å¤šæ ¼å¼æ–‡ä»¶æ”¯æŒæµ‹è¯•
        describe('å¤šæ ¼å¼æ–‡ä»¶æ”¯æŒ', () => {
            let fileProcessor;

            beforeEach(() => {
                fileProcessor = window.FileProcessor || {
                    processTextFile: (content) => content.split('\n').filter(line => line.trim()),
                    processExcelFile: (data) => data.flat(),
                    detectEncoding: (buffer) => 'UTF-8'
                };
            });

            test('æ–‡æœ¬æ–‡ä»¶å¤„ç†', () => {
                const content = 'apple\nbanana\ncat\n\ndog';
                const result = fileProcessor.processTextFile(content);
                return result;
            }, {
                input: 'apple\nbanana\ncat\n\ndog',
                expected: ['apple', 'banana', 'cat', 'dog']
            });

            test('Excelæ–‡ä»¶å¤„ç†', () => {
                const data = [['apple', 'banana'], ['cat', 'dog']];
                const result = fileProcessor.processExcelFile(data);
                return result;
            }, {
                input: [['apple', 'banana'], ['cat', 'dog']],
                expected: ['apple', 'banana', 'cat', 'dog']
            });

            test('ç¼–ç è¯†åˆ«', () => {
                const buffer = new ArrayBuffer(8);
                const result = fileProcessor.detectEncoding(buffer);
                return result;
            }, {
                input: 'ArrayBuffer',
                expected: 'UTF-8'
            });
        }, 'fileProcessor');

        // ==================== æ•°æ®æŒä¹…åŒ–ä¸åŒæ­¥ç³»ç»Ÿæµ‹è¯• ====================

        // 1. localStorage å­˜å‚¨æµ‹è¯•
        describe('localStorageå­˜å‚¨', () => {
            let storageManager;

            beforeEach(() => {
                storageManager = window.StorageManager || {
                    saveRuleData: (name, data) => ({ success: true, stored: true }),
                    saveGlobalSets: (sets) => ({ success: true, synced: true }),
                    checkDataIntegrity: (data) => ({ recovered: true, useDefault: true })
                };
            });

            test('è§„åˆ™æ•°æ®å­˜å‚¨', () => {
                const input = {
                    ruleName: 'æµ‹è¯•è§„åˆ™',
                    ruleData: {
                        name: 'æµ‹è¯•è§„åˆ™',
                        comment: 'æµ‹è¯•æ³¨é‡Š',
                        localSets: [['å…ƒéŸ³', ['a', 'e', 'i']]],
                        specificRule: 'V',
                        displayRule: '@V'
                    }
                };
                const result = storageManager.saveRuleData(input.ruleName, input.ruleData);
                return result;
            }, {
                input: { ruleName: 'æµ‹è¯•è§„åˆ™', ruleData: {} },
                expected: { success: true, stored: true }
            });

            test('å…¨å±€é›†åˆå­˜å‚¨', () => {
                const input = {
                    globalSets: {
                        'è‡ªå®šä¹‰å…ƒéŸ³': ['a', 'e', 'i', 'o', 'u'],
                        'è‡ªå®šä¹‰è¾…éŸ³': ['b', 'c', 'd', 'f']
                    }
                };
                const result = storageManager.saveGlobalSets(input.globalSets);
                return result;
            }, {
                input: { globalSets: {} },
                expected: { success: true, synced: true }
            });

            test('æ•°æ®å®Œæ•´æ€§éªŒè¯', () => {
                const input = { corruptedData: '{"invalid": json}' };
                const result = storageManager.checkDataIntegrity(input.corruptedData);
                return result;
            }, {
                input: { corruptedData: 'invalid' },
                expected: { recovered: true, useDefault: true }
            });
        }, 'dataSync');

        // ==================== æ™ºèƒ½æ–‡ä»¶å¤„ç†ç³»ç»Ÿæµ‹è¯• ============================

        describe('FileUtils åŸºç¡€åŠŸèƒ½', () => {
            test('æ–‡æœ¬å†…å®¹è§£æ', () => {
                const content = 'apple\nbanana\ncat';
                const result = FileUtils.parseTextContent(content);
                expect(result).toContain('apple');
                expect(result).toContain('banana');
                expect(result).toContain('cat');
                return result;
            }, {
                input: 'apple\nbanana\ncat',
                expected: ['apple', 'banana', 'cat']
            });

            test('ç©ºå†…å®¹å¤„ç†', () => {
                const content = '';
                const result = FileUtils.parseTextContent(content);
                expect(result.length).toBe(0);
                return result;
            }, {
                input: '',
                expected: []
            });
        }, 'fileUtils');

        // FileStorageManager åŸºç¡€æµ‹è¯•
        describe('FileStorageManager åŸºç¡€åŠŸèƒ½', () => {
            let storageManager;

            beforeEach(() => {
                storageManager = new FileStorageManager();
                localStorage.clear();
            });

            test('æ–‡ä»¶ä¿å­˜åŠŸèƒ½', () => {
                const fileData = { name: 'test.txt', content: 'test content' };
                storageManager.saveFile(fileData);
                const saved = storageManager.getFile('test.txt');
                expect(saved.name).toBe('test.txt');
                expect(saved.content).toBe('test content');
                return saved;
            }, {
                input: { name: 'test.txt', content: 'test content' },
                expected: { name: 'test.txt', content: 'test content' }
            });

            test('æ–‡ä»¶åˆ—è¡¨åŠŸèƒ½', () => {
                const file1 = { name: 'file1.txt', content: 'content1' };
                const file2 = { name: 'file2.txt', content: 'content2' };
                storageManager.saveFile(file1);
                storageManager.saveFile(file2);
                const files = storageManager.listFiles();
                expect(files.length).toBe(2);
                return files.map(f => f.name);
            }, {
                input: [{ name: 'file1.txt' }, { name: 'file2.txt' }],
                expected: ['file1.txt', 'file2.txt']
            });

            test('æ–‡ä»¶åˆ é™¤åŠŸèƒ½', () => {
                const fileData = { name: 'test.txt', content: 'test content' };
                storageManager.saveFile(fileData);
                storageManager.deleteFile('test.txt');
                const files = storageManager.listFiles();
                expect(files.length).toBe(0);
                return files.length;
            }, {
                input: 'test.txt',
                expected: 0
            });
        }, 'fileStorage');

        // ==================== é›†æˆæµ‹è¯• ====================

        describe('è§„åˆ™å¼•æ“é›†æˆæµ‹è¯•', () => {
            let ruleEngine;
            let storageManager;

            beforeEach(() => {
                ruleEngine = new RuleEngine();
                storageManager = new FileStorageManager();
                localStorage.clear();
            });

            test('è§„åˆ™ä¿å­˜å’ŒåŠ è½½', () => {
                const ruleText = '#æµ‹è¯•è§„åˆ™\n:L=5';
                const rule = ruleEngine.parseRule(ruleText);
                storageManager.saveFile({ name: 'test-rule.txt', content: ruleText });
                const savedFile = storageManager.getFile('test-rule.txt');
                const loadedRule = ruleEngine.parseRule(savedFile.content);
                expect(loadedRule.name).toBe(rule.name);
                return { original: rule.name, loaded: loadedRule.name };
            }, {
                input: '#æµ‹è¯•è§„åˆ™\n:L=5',
                expected: { original: 'æµ‹è¯•è§„åˆ™', loaded: 'æµ‹è¯•è§„åˆ™' }
            });

            test('å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•', () => {
                const wordList = 'apple\nbanana\ncat\ndog';
                const ruleText = '#é•¿åº¦è§„åˆ™\n:L>=3';
                storageManager.saveFile({ name: 'words.txt', content: wordList });
                storageManager.saveFile({ name: 'rule.txt', content: ruleText });
                const wordsFile = storageManager.getFile('words.txt');
                const ruleFile = storageManager.getFile('rule.txt');
                const words = FileUtils.parseTextContent(wordsFile.content);
                const rule = ruleEngine.parseRule(ruleFile.content);
                expect(words.length).toBe(4);
                expect(rule.name).toBe('é•¿åº¦è§„åˆ™');
                return { wordCount: words.length, ruleName: rule.name };
            }, {
                input: { words: 'apple\nbanana\ncat\ndog', rule: '#é•¿åº¦è§„åˆ™\n:L>=3' },
                expected: { wordCount: 4, ruleName: 'é•¿åº¦è§„åˆ™' }
            });
        }, 'integration');

        describe('ç³»ç»Ÿæ€§èƒ½æµ‹è¯•', () => {
            test('å¤§é‡æ•°æ®å¤„ç†', () => {
                const largeWordList = Array.from({ length: 1000 }, (_, i) => `word${i}`).join('\n');
                const startTime = performance.now();
                const words = FileUtils.parseTextContent(largeWordList);
                const endTime = performance.now();
                const processingTime = endTime - startTime;
                expect(words.length).toBe(1000);
                expect(processingTime).toBeLessThan(100); // åº”è¯¥åœ¨100mså†…å®Œæˆ
                return { wordCount: words.length, time: processingTime };
            }, {
                input: '1000ä¸ªå•è¯',
                expected: { wordCount: 1000, timeLimit: '< 100ms' }
            });

            test('è§„åˆ™è§£ææ€§èƒ½', () => {
                const complexRule = '#å¤æ‚è§„åˆ™\nVowels=={a,e,i,o,u}\nConsonants=={b,c,d,f,g}\n:Vowels>=2 && Consonants>=3';
                const startTime = performance.now();
                const ruleEngine = new RuleEngine();
                const rule = ruleEngine.parseRule(complexRule);
                const endTime = performance.now();
                const processingTime = endTime - startTime;
                expect(rule.name).toBe('å¤æ‚è§„åˆ™');
                expect(processingTime).toBeLessThan(50); // åº”è¯¥åœ¨50mså†…å®Œæˆ
                return { ruleName: rule.name, time: processingTime };
            }, {
                input: 'å¤æ‚è§„åˆ™è§£æ',
                expected: { ruleName: 'å¤æ‚è§„åˆ™', timeLimit: '< 50ms' }
            });
        }, 'performance');

        describe('é”™è¯¯å¤„ç†æµ‹è¯•', () => {
            test('æ— æ•ˆè§„åˆ™å¤„ç†', () => {
                const ruleEngine = new RuleEngine();
                try {
                    ruleEngine.parseRule('#æ— æ•ˆè§„åˆ™');
                    return false;
                } catch (error) {
                    return error.message.includes('å…·ä½“è§„åˆ™ä¸èƒ½ä¸ºç©º');
                }
            }, {
                input: '#æ— æ•ˆè§„åˆ™',
                expected: true
            });

            test('æ–‡ä»¶ä¸å­˜åœ¨å¤„ç†', () => {
                const storageManager = new FileStorageManager();
                try {
                    const file = storageManager.getFile('nonexistent.txt');
                    return file === null;
                } catch (error) {
                    return true;
                }
            }, {
                input: 'nonexistent.txt',
                expected: true
            });

            test('ç©ºæ–‡ä»¶å†…å®¹å¤„ç†', () => {
                const result = FileUtils.parseTextContent('');
                expect(result.length).toBe(0);
                return result.length === 0;
            }, {
                input: '',
                expected: true
            });
        }, 'errorHandling');

        // é¡µé¢åŠ è½½å®Œæˆåæ˜¾ç¤ºè¯´æ˜
        window.addEventListener('load', () => {
            console.log('ğŸ§ª å•å…ƒæµ‹è¯•è¿è¡Œå™¨å·²åŠ è½½');
            console.log('ç‚¹å‡» "è¿è¡Œæ‰€æœ‰æµ‹è¯•" æŒ‰é’®å¼€å§‹æµ‹è¯•');
        });
    </script>
</body>

</html>