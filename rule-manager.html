<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>规则管理 - 单词筛选工具</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        .rule-manager-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
        }

        @media (max-width: 768px) {
            .rule-manager-container {
                padding: 10px !important;
                /* max-width: 100% !important; */
            }
        }

        .rule-manager-header,
        .rule-manager-header {
            text-align: left !important;
        }

        .rule-manager-header h1 {
            text-align: left !important;
        }

        .rule-manager-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
            /* gap: 15px; */
            /* 强制左对齐，覆盖全局header */
        }

        .rule-manager-header h1 {
            font-size: 1.5rem;
            margin: 0;
            margin-right: 15px;
        }

        .rule-manager-header p {
            font-size: 0.9rem;
            margin: 0;
            color: white;
        }

        .rule-manager-header>div:first-child {
            display: flex;
            align-items: baseline;
            gap: 15px;
            justify-content: flex-start;
            flex: 0 1 auto;
            min-width: 0;
        }

        .rule-manager-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 60vh;
        }

        @media (max-width: 768px) {
            .rule-manager-content {
                padding: 10px !important;
                gap: 15px !important;
                max-width: 100% !important;
            }
        }

        .rule-panels {
            display: flex;
            gap: 20px;
        }

        .rule-examples-panel {
            flex: 1;
            max-width: 50%;
            min-height: 400px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .rule-editor-panel {
            flex: 1;
            max-width: 50%;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-title {
            margin: 0 0 20px 0;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }

        .rule-textarea {
            width: 100%;
            min-height: 300px;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            background: #f8fafc;
            transition: border-color 0.3s ease;
        }

        .rule-textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .examples-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .examples-header .panel-title {
            margin: 0;
        }

        .toggle-all-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toggle-all-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .toggle-all-btn:active {
            transform: translateY(0);
        }

        .example-section {
            margin-bottom: 0;
        }

        .example-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
            background: #f8fafc;
            border-radius: 6px;
            transition: all 0.3s ease;
            user-select: none;
        }

        .example-title:hover {
            background: #e2e8f0;
            color: #2d3748;
        }

        .example-title::before {
            content: "📝";
            margin-right: 8px;
        }

        .example-title::after {
            content: "▼";
            margin-left: auto;
            font-size: 0.8rem;
            transition: transform 0.3s ease;
            color: #718096;
        }

        .example-section.collapsed .example-title::after {
            transform: rotate(-90deg);
        }

        .example-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            max-height: 1000px;
            opacity: 1;
        }

        .example-section.collapsed .example-content {
            max-height: 0;
            opacity: 0;
            margin-bottom: 0;
        }

        .example-code {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            overflow-x: auto;
            position: relative;
            margin-bottom: 10px;
        }

        .example-description {
            color: #718096;
            font-size: 0.9rem;
            margin-bottom: 15px;
            padding: 10px;
            background: #f7fafc;
            border-left: 4px solid #667eea;
            border-radius: 0 4px 4px 0;
        }

        .example-code .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #4a5568;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .example-code .copy-btn:hover {
            background: #667eea;
        }

        .rule-actions {
            display: flex;
            gap: 10px;
            margin-top: 0px;
            flex-wrap: wrap;
        }

        .saved-rules-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .saved-rules-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .saved-rules-header h2 {
            margin: 0 0 0 0;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            font-size: 1.17em;
        }

        .saved-rules-container {
            display: flex;
            flex-direction: column;
            gap: 0;
            max-height: 1000px;
            overflow-y: auto;
            padding: 0;
            min-height: 100px;
            background: transparent;
            border: none;
        }

        .saved-rules-container.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translateY(-30px);
        }

        .rule-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 5px 11.2px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            margin-top: -1px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            overflow: hidden;
        }

        .rule-item-header:first-child {
            margin-top: 0;
        }

        /* 强制为所有最后的rule-item-content添加下边线 - 使用更高优先级 */
        .rule-tree .rule-item-content:last-child {
            border-bottom: 1px solid #e2e8f0 !important;
            border-left: 1px solid #e2e8f0 !important;
            border-right: 1px solid #e2e8f0 !important;
        }

        /* 强制为rule-tree直接子元素的最后一个content添加下边线 */
        .rule-tree>div:last-child.rule-item-content {
            border-bottom: 1px solid #e2e8f0 !important;
            border-left: 1px solid #e2e8f0 !important;
            border-right: 1px solid #e2e8f0 !important;
        }

        /* 确保最后一个rule-item-header的下一个兄弟元素rule-item-content有下边线 */
        .rule-tree .rule-item-header:nth-last-child(2)+.rule-item-content {
            border-bottom: 1px solid #e2e8f0 !important;
            border-left: 1px solid #e2e8f0 !important;
            border-right: 1px solid #e2e8f0 !important;
        }

        /* 通用强制样式 - 确保任何情况下最后的content都有下边线 */
        div.rule-item-content:last-child {
            border-bottom: 1px solid #e2e8f0 !important;
        }

        .rule-item-header:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .rule-item-name {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #2d3748;
            flex-shrink: 0;
        }

        .rule-item-content {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            color: #e2e8f0;
            background: #2d3748;
            padding: 16px;
            border-left: 1px solid #4a5568;
            border-right: 1px solid #4a5568;
            border-radius: 0 0 8px 8px;
            overflow-x: auto;
            white-space: pre-wrap;
            display: block;
            line-height: 1.6;
        }

        .rule-item.collapsed .rule-item-content {
            display: none;
        }

        .rule-item-content.expanded {
            display: block;
        }



        .rule-item-actions {
            display: flex;
            gap: 0;
            flex-shrink: 0;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
        }

        .syntax-help {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 0;
        }

        .syntax-help h4 {
            color: #c53030;
            /* margin-bottom: 10px; */
            align-items: baseline;
        }

        .syntax-list {
            list-style: none;
            padding: 0;
        }

        .syntax-list li {
            padding: 5px 0;
            border-bottom: 1px solid #fed7d7;
        }

        .syntax-list li:last-child {
            border-bottom: none;
        }

        .syntax-code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background: #f7fafc;
            padding: 2px 6px;
            border-radius: 3px;
            color: #2d3748;
        }

        .global-sets-editor {
            background: #f8f9fa;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 0;
        }

        .global-sets-editor h4 {
            margin-bottom: 10px;
        }

        .global-sets-textarea {
            width: 100%;
            min-height: 180px;
            padding: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 10px;
            word-break: break-all;
            white-space: pre-wrap;
        }

        .global-sets-display {
            background: #f0f8ff;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .global-sets-display h4 {
            color: #1e40af;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .global-sets-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .global-set-item {
            background: #dbeafe;
            color: #1e40af;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid #93c5fd;
        }

        .rule-tree {
            list-style: none;
            padding: 0;
            margin: 0;
            font-family: 'Courier New', monospace;
            border-collapse: collapse;
        }

        .rule-tree-item {
            margin-bottom: 5px;
        }

        /* @media (max-width: 1024px) {
            .rule-panels {
                flex-direction: column;
            }

            .rule-examples-panel,
            .rule-editor-panel {
                max-width: 100%;
                flex: none;
            }
        } */

        @media (max-width: 768px) {
            .rule-manager-header {
                flex-direction: row;
                /* gap: 15px; */
                padding-bottom: 15px;
                align-items: flex-start;
            }

            .rule-manager-header h1 {
                font-size: 1.2rem;
                margin-bottom: 0;
            }

            .rule-panels {
                flex-direction: column;
                gap: 15px;
            }

            .rule-examples-panel,
            .rule-editor-panel {
                max-width: 100%;
                flex: none;
                min-height: auto;
            }

            .rule-textarea {
                min-height: 200px;
            }

            .global-sets-textarea {
                min-height: 180px;
            }
        }

        @media (max-width: 768px) {
            .rule-manager-header {
                padding-bottom: 15px !important;
                margin: 10px !important;
                flex-direction: column !important;
                /* gap: 10px !important; */
            }

            .rule-manager-header h1 {
                font-size: 1.5rem !important;
                /* margin-bottom: 10px !important; */
            }

            .rule-actions {
                display: flex !important;
                flex-direction: row !important;
                gap: 5px !important;
                flex-wrap: nowrap !important;
                justify-content: space-between !important;
                margin-top: 0px !important;
            }

            .rule-actions .btn {
                flex: 1 !important;
                padding: 8px 4px !important;
                font-size: 14px !important;
                min-width: 0 !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                margin: 0 !important;
            }

            .global-actions {
                display: flex !important;
                flex-direction: row !important;
                gap: 5px !important;
                flex-wrap: nowrap !important;
                justify-content: space-between !important;
                margin-top: 0px !important;
            }

            .global-actions .btn {
                flex: 1 !important;
                padding: 8px 4px !important;
                font-size: 14px !important;
                min-width: 0 !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                margin: 0 !important;
            }

            .btn {
                padding: 8px 12px !important;
                font-size: 14px !important;
                min-width: auto !important;
            }

            .rule-examples-panel,
            .rule-editor-panel {
                padding: 15px !important;
                max-width: 100% !important;
                margin: 0 !important;
            }

            .rule-textarea,
            .global-sets-textarea {
                font-size: 0.9rem !important;
                padding: 10px !important;
            }

            .rule-textarea {
                min-height: 240px !important;
            }

            .global-sets-textarea {
                min-height: 150px !important;
            }

            /* .rule-panels {
                flex-direction: column !important;
                gap: 15px !important;
            } */

            /* 已保存的规则区域在窄屏下的布局调整 */
            .saved-rules-header {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 15px !important;
            }

            .saved-rules-header h2 {
                margin-bottom: 0 !important;
                width: 100% !important;
            }

            .saved-rules-header>div {
                margin-left: 0 !important;
                width: 100% !important;
                justify-content: space-between !important;
                flex-wrap: nowrap !important;
                gap: 5px !important;
            }

            .saved-rules-header .btn {
                flex: 1 !important;
                padding: 6px 4px !important;
                font-size: 14px !important;
                min-width: 0 !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
            }
        }



        /* 图标按钮样式 */
        .btn-icon {
            background: none;
            border: none;
            padding: 4px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .btn-icon:hover {
            background: #f3f4f6;
        }

        .btn-icon:active {
            background: #e5e7eb;
        }

        /* 小按钮样式 */
        .btn-small {
            padding: 4px 8px;
            font-size: 14px;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <div class="rule-manager-container">
        <header class="rule-manager-header">
            <div>
                <h1>规则管理</h1>
                <p>创建和管理单词筛选规则</p>
            </div>
            <div class="header-buttons">
            </div>
        </header>

        <!-- 上半区：左右布局 -->
        <div class="rule-manager-content">
            <div class="rule-panels">
                <!-- 左侧：示例区域 -->
                <div class="rule-examples-panel">
                    <div class="examples-header">
                        <h3 class="panel-title">规则示例</h3>
                        <button class="btn btn-small btn-outline" onclick="toggleAllExamples()" title="收缩/展开全部示例">
                            <span class="toggle-all-text">➖ 收缩全部示例</span>
                        </button>
                    </div>

                    <div class="example-section">
                        <div class="example-title" onclick="toggleExample(this)">四字母及以上单词</div>
                        <div class="example-content">
                            <div class="example-code"
                                style="background-color: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: 'Consolas', 'Monaco', monospace;">
                                <button class="copy-btn" onclick="copyExample(this)">复制</button>
                                <div style="line-height: 1.6;">
                                    <div><span style="color: #68d391;">#四字母及以上单词</span></div>
                                    <div><span style="color: #63b3ed;">:\bLLLL</span></div>
                                    <div><span style="color: #f6e05e;">@</span></div>
                                </div>
                            </div>
                            <div class="example-description">
                                <div style="margin-bottom: 8px;"><strong>功能：</strong>匹配包含四个或更多字母的单词。</div>
                                <div style="margin-bottom: 8px;"><strong>语法：</strong><span
                                        class="syntax-code">:\bLLLL</span>（部分匹配模式）</div>
                                <div style="margin-bottom: 8px;"><strong>集合：</strong><span
                                        class="syntax-code">L</span>（全局集合，包含小写字母a-z）</div>
                                <div style="margin-bottom: 8px;">
                                    <strong>排序：</strong><span class="syntax-code">@</span>为空，则表示按字母顺序排序；<span
                                        class="syntax-code">@-</span>，则表示按字母降序排序。
                                </div>
                                <div style="margin-bottom: 8px;"><strong>示例：</strong>book, tree, jump, play, hello,
                                    world,
                                    beautiful, wonderful</div>
                                <div style="color: #666; font-size: 0.9em;">注：如需恰好四个字母，语法请使用 :<span
                                        class="syntax-code"><span style="color: red;">\b</span>LLLL<span
                                            style="color: red;">\e</span></span></div>
                            </div>
                        </div>
                    </div>

                    <div class="example-section">
                        <div class="example-title" onclick="toggleExample(this)">双辅音开头</div>
                        <div class="example-content">
                            <div class="example-code"
                                style="background-color: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: 'Consolas', 'Monaco', monospace;">
                                <button class="copy-btn" onclick="copyExample(this)">复制</button>
                                <div style="line-height: 1.6;">
                                    <div><span style="color: #68d391;">#双辅音开头</span></div>
                                    <div><span
                                            style="color: #ed64a6;">BL=={bl,br,cl,cr,dr,fl,fr,gl,gr,pl,pr,sc,sk,sl,sm,sn,sp,st,sw,tr,tw}</span>
                                    </div>
                                    <div><span style="color: #63b3ed;">:\b(BL)</span></div>
                                    <div><span style="color: #f6e05e;">@(BL^)</span></div>
                                </div>
                            </div>
                            <div class="example-description">
                                <div style="margin-bottom: 8px;"><strong>功能：</strong>匹配以双辅音开头的单词。</div>
                                <div style="margin-bottom: 8px;"><strong>语法：</strong><span
                                        class="syntax-code">:\b(BL)</span>（部分匹配模式）</div>
                                <div style="margin-bottom: 8px;">
                                    <strong>集合：</strong><span class="syntax-code">BL</span>（局部集合）
                                </div>
                                <div style="margin-bottom: 8px;"><strong>排序：</strong>按集合<span
                                        class="syntax-code">BL</span>包含的元素分组排序。</div>
                                <div style="margin-bottom: 8px;"><strong>示例：</strong>black, brown, class, green, play,
                                    tree,
                                    stop, swim</div>
                                <div style="color: #666; font-size: 0.9em;">
                                    注：<br>1、<span
                                        class="syntax-code">\b</span>表示单词开头。（更多位置标志参见详细语法帮助）<br>2、两个字母以上的集合需用括号引用。（如<span
                                        class="syntax-code">(BL)</span>）<br>3、可以在排序<span
                                        class="syntax-code">(BL)</span>前添加<span class="syntax-code"
                                        style="background-color: lightyellow;">-</span>表示按集合<span
                                        class="syntax-code">BL</span>内的元素逆序分组。（如<span
                                        class="syntax-code">-(BL)</span>）<br>4、排序支持多级排序和位置匹配符。（参见详细语法帮助）
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="example-section">
                        <div class="example-title" onclick="toggleExample(this)">CVC模式</div>
                        <div class="example-content">
                            <div class="example-code"
                                style="background-color: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: 'Consolas', 'Monaco', monospace;">
                                <button class="copy-btn" onclick="copyExample(this)">复制</button>
                                <div style="line-height: 1.6;">
                                    <div><span style="color: #68d391;">#CVC</span></div>
                                    <div><span style="color: #68d391;">//辅音-元音-辅音（去y）</span></div>
                                    <div><span style="color: #ed64a6;">eC==C>>{y}</span></div>
                                    <div><span style="color: #63b3ed;">:\bCV(eC)\e</span></div>
                                    <div><span style="color: #f6e05e;">@</span></div>
                                </div>
                            </div>
                            <div class="example-description">
                                <div style="margin-bottom: 8px;"><strong>功能：</strong>完整匹配辅音-元音-辅音（去y）结构的三字母单词。</div>
                                <div style="margin-bottom: 8px;"><strong>语法：</strong><span
                                        class="syntax-code">:\bCV(eC)\e</span>（完整匹配模式）</div>
                                <div style="margin-bottom: 8px;">
                                    <strong>集合：</strong><span class="syntax-code">C</span>（全局集合，辅音字母集合）、<span
                                        class="syntax-code">V</span>（全局集合，元音字母集合）、<span
                                        class="syntax-code">eC</span>（局部集合，不含<span class="syntax-code">y</span>的辅音字母集合）
                                </div>
                                <div style="margin-bottom: 8px;"><strong>示例：</strong>cat, dog, run, big, hat, pen, sit,
                                    cup
                                </div>
                                <div style="color: #666; font-size: 0.9em;">
                                    注：<span class="syntax-code">eC==C>>{y}</span>表示从集合<span
                                        class="syntax-code">C</span>中去掉<span class="syntax-code">y</span>，得到新的局部集合<span
                                        class="syntax-code">eC</span>。（更多集合运算符参见详细语法帮助）</div>
                            </div>
                        </div>
                    </div>

                    <div class="example-section">
                        <div class="example-title" onclick="toggleExample(this)">CVCE模式（魔法E）</div>
                        <div class="example-content">
                            <div class="example-code"
                                style="background-color: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: 'Consolas', 'Monaco', monospace;">
                                <button class="copy-btn" onclick="copyExample(this)">复制</button>
                                <div style="line-height: 1.6;">
                                    <div><span style="color: #68d391;">#CVCE</span></div>
                                    <div><span style="color: #68d391;">//辅音-元音-辅音-e</span></div>
                                    <div><span style="color: #63b3ed;">:\bCVC"e"\e</span></div>
                                    <div><span style="color: #f6e05e;">@</span></div>
                                </div>
                            </div>
                            <div class="example-description">
                                <div style="margin-bottom: 8px;"><strong>功能：</strong>完整匹配辅音-元音-辅音-e结构的四字母单词。</div>
                                <div style="margin-bottom: 8px;"><strong>语法：</strong><span
                                        class="syntax-code">:!\bCVC"e"\e</span>（完整匹配模式）</div>
                                <div style="margin-bottom: 8px;"><strong>集合：</strong><span
                                        class="syntax-code">C</span>、<span class="syntax-code">V</span>、<span
                                        class="syntax-code">"e"</span>（字面字符）</div>
                                <div style="margin-bottom: 8px;"><strong>示例：</strong>cake, make, bike, home, cute, hope,
                                    time, name</div>
                                <div style="color: #666; font-size: 0.9em;">注：使用双引号<span class="syntax-code"
                                        style="background-color: lightyellow;">"
                                        "</span>表示字面字符，用于匹配具体的字符或字符串。（如<span class="syntax-code">"e"</span>、<span
                                        class="syntax-code">"tion"</span>）</div>
                            </div>
                        </div>
                    </div>

                    <div class="example-section">
                        <div class="example-title" onclick="toggleExample(this)"><span style="color: red;">组合规则</span>
                        </div>
                        <div class="example-content">
                            <div class="example-code"
                                style="background-color: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: 'Consolas', 'Monaco', monospace;">
                                <button class="copy-btn" onclick="copyExample(this)">复制</button>
                                <div style="line-height: 1.6;">
                                    <div><span style="color: #68d391;">#CVC或CVCE</span></div>
                                    <div><span style="color: #63b3ed;">::CVC||CVCE</span></div>
                                    <div><span style="color: #f6e05e;">@</span></div>
                                </div>
                            </div>
                            <div class="example-description">
                                <div style="margin-bottom: 8px;"><strong>功能：</strong>匹配满足<span
                                        class="syntax-code">CVC</span>模式或<span class="syntax-code">CVCE</span>模式的单词。
                                </div>
                                <div style="margin-bottom: 8px;"><strong>语法：</strong><span
                                        class="syntax-code">::CVC||CVCE</span>（双冒号<span class="syntax-code"
                                        style="background-color: lightyellow;">::</span>表示组合规则模式）
                                </div>
                                <div style="margin-bottom: 8px;"><strong>集合：</strong>无（组合规则必须引用已定义的规则名）
                                </div>
                                <div style="margin-bottom: 8px;"><strong>示例：</strong>cat, dog, run, big, cake, make,
                                    bike,
                                    home</div>
                                <div style="margin-bottom: 8px;"><strong><span
                                            style="color: red;">支持的操作符：</span></strong>
                                </div>
                                <div style="margin-left: 16px;">
                                    <div style="margin-bottom: 4px;">• <span class="syntax-code"
                                            style="background-color: lightyellow;">||</span> - 或（满足任一条件）</div>
                                    <div style="margin-bottom: 4px;">• <span class="syntax-code"
                                            style="background-color: lightyellow;">&&</span> - 与（同时满足两个条件）</div>
                                    <div style="margin-bottom: 4px;">• <span class="syntax-code"
                                            style="background-color: lightyellow;">!</span> - 差集（满足前者但不满足后者）</div>
                                    <div style="margin-bottom: 4px;">• <span class="syntax-code"
                                            style="background-color: lightyellow;">~</span> - 取反（对规则结果取反）</div>
                                </div>
                                <div style="margin-bottom: 12px; color: #666; font-size: 0.9em;">
                                    注：更多组合规则说明参见详细语法帮助。</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 规则编辑器 -->
                <div class="rule-editor-panel">
                    <h3 class="panel-title">规则编辑器</h3>

                    <div class="syntax-help">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4>快速语法提示</h4>
                            <button id="detailedHelpBtn" class="btn btn-outline btn-small">详细语法帮助</button>
                        </div>
                        <ul class="syntax-list">
                            <li><span class="syntax-code">#规则名</span> - 定义规则名称（必须，以<span class="syntax-code">#</span>开头）
                            </li>
                            <li><span class="syntax-code">//注释内容</span> - 添加规则注释（可选，以<span
                                    class="syntax-code">//</span>开头）</li>
                            <li><span class="syntax-code">集合名=={元素1,元素2,...}</span> - 定义局部集合（可选，单字母集合名必须大写，多字母集合名大小写敏感）
                            </li>
                            <li><span class="syntax-code">:筛选规则</span> - 定义匹配模式（必须，以<span
                                    class="syntax-code">:</span>或<span class="syntax-code">::</span>开头）
                            </li>
                            <li><span class="syntax-code">@排序规则</span> - 定义排序方式（可选，以<span
                                    class="syntax-code">@</span>或<span class="syntax-code">@@</span>开头）
                            </li>
                        </ul>
                    </div>

                    <!-- 全局集合编辑区 -->
                    <div class="global-sets-editor">
                        <h4>全局集合定义</h4>
                        <textarea id="globalSetsEditor" class="global-sets-textarea"
                            placeholder="在此定义全局集合，每行一个集合定义，格式：集合名=={元素1,元素2,...}\n例如：\nC=={b,c,d,f,g,h,j,k,l,m,n,p,q,r,s,t,v,w,x,y,z}\nV=={a,e,i,o,u}">C=={b,c,d,f,g,h,j,k,l,m,n,p,q,r,s,t,v,w,x,y,z}\nV=={a,e,i,o,u}\nL=={a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}</textarea>
                        <div class="global-actions" style="margin-top: 0px; display: flex; gap: 10px;">
                            <button id="updateGlobalSetsBtn" class="btn btn-primary"
                                style="margin-right: 5px;">更新全局集合</button>
                            <button id="exportRulesFromGlobalBtn" class="btn btn-secondary">导出规则</button>
                            <button id="importRulesFromGlobalBtn" class="btn btn-secondary">导入规则</button>
                        </div>
                    </div>





                    <textarea id="ruleEditor" class="rule-textarea" placeholder="在此输入规则...

注意：
• 筛选规则中可引用全局集合和局部集合。
  ◦ 局部集合必须在当前规则中定义才能引用。
  ◦ 多字母集合名必须使用 (集合名) 引用。
• 筛选规则中可使用 \位置标志 强制位置匹配。
  ◦ \b - 单词开头，\e - 单词结尾
  ◦ 更多参见详细语法帮助，"></textarea>

                    <div class="rule-actions">
                        <button id="saveRuleBtn" class="btn btn-primary">保存规则</button>
                        <button id="testRuleBtn" class="btn btn-secondary" style="margin-right: 5px;">测试规则</button>
                        <button id="formatRuleBtn" class="btn btn-secondary">格式化</button>
                        <button id="clearRuleBtn" class="btn btn-danger">清空编辑器</button>

                    </div>
                </div>
            </div>

            <!-- 下半区：已保存的规则 -->
            <div class="saved-rules-section">
                <div class="saved-rules-header">
                    <h2>已保存的规则</h2>
                    <div style="margin-left: auto; display: flex; gap: 10px;">
                        <button class="btn btn-small btn-outline" onclick="toggleAllSavedRules()" title="收缩/展开全部规则">
                            <span class="toggle-all-saved-text">➖ 收缩全部规则</span>
                        </button>
                        <button id="exportRulesBtn" class="btn btn-secondary">导出规则</button>
                        <button id="importRulesBtn" class="btn btn-secondary">导入规则</button>
                        <button id="clearAllRulesBtn" class="btn btn-danger" onclick="ruleManager.clearAllRules()">
                            🗑️ 清除所有规则
                        </button>
                    </div>
                </div>
                <div class="drag-sort-hint"
                    style="color: #718096; font-size: 14px; margin-bottom: 5px; display: flex; align-items: center; gap: 5px;">
                    <span>⋮⋮</span>
                    <span>拖动可调整排序</span>
                </div>
                <div id="savedRulesContainer" class="saved-rules-container"></div>
            </div>
        </div>
    </div>

    <!-- 消息提示 -->
    <div id="messageContainer" class="message-container"></div>

    <!-- 加载指示器 -->
    <div id="loadingIndicator" class="loading-indicator" style="display: none;">
        <div class="spinner"></div>
        <p>正在处理...</p>
    </div>

    <!-- 引入外部库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- 引入自定义脚本 -->
    <script src="js/fileUtils.js"></script>
    <script src="js/fileStorage.js"></script>
    <script src="js/ruleEngine.js"></script>
    <script src="js/version.js"></script>
    <script>
        // 规则管理页面专用脚本
        class RuleManagerApp {
            constructor() {
                this.ruleEngine = new RuleEngine();
                this.ruleOrder = []; // 初始化规则顺序数组
                this.initializeApp();
            }

            initializeApp() {
                this.bindEvents();
                this.ruleEngine.loadSavedRules();
                this.loadSavedRules();
                this.initializeGlobalSetsEditor();
            }

            // 初始化全局集合编辑器
            initializeGlobalSetsEditor() {
                const globalSetsEditor = document.getElementById('globalSetsEditor');
                const savedGlobalSets = JSON.parse(localStorage.getItem('globalSets') || '{}');

                let defaultSets = `C=={b,c,d,f,g,h,j,k,l,m,n,p,q,r,s,t,v,w,x,y,z}
V=={a,e,i,o,u}
L=={a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}`;

                // 添加保存的自定义集合
                for (const [setName, setValues] of Object.entries(savedGlobalSets)) {
                    // 检查是否为内置集合
                    const builtinSets = this.ruleEngine.getBuiltinSetNames();
                    if (!builtinSets.includes(setName)) {
                        defaultSets += `\n${setName}=={${setValues.join(',')}}`;
                    }
                }

                globalSetsEditor.value = defaultSets;
            }

            bindEvents() {
                // 导出规则按钮
                document.getElementById('exportRulesBtn').addEventListener('click', async () => {
                    await this.exportRules();
                });

                // 导入规则按钮
                document.getElementById('importRulesBtn').addEventListener('click', () => {
                    this.importRules();
                });



                // 保存规则
                document.getElementById('saveRuleBtn').addEventListener('click', () => {
                    this.saveRule();
                });

                // 测试规则
                document.getElementById('testRuleBtn').addEventListener('click', () => {
                    this.testRule();
                });

                // 清空编辑器
                document.getElementById('clearRuleBtn').addEventListener('click', () => {
                    if (confirm('确定要清空编辑器内容吗？')) {
                        document.getElementById('ruleEditor').value = '';
                    }
                });

                // 格式化规则
                document.getElementById('formatRuleBtn').addEventListener('click', () => {
                    this.formatRule();
                });

                // 规则编辑器粘贴事件 - 自动格式化
                document.getElementById('ruleEditor').addEventListener('paste', (event) => {
                    // 延迟执行格式化，确保粘贴内容已经插入
                    setTimeout(() => {
                        this.formatRule();
                    }, 10);
                });

                // 更新全局集合
                document.getElementById('updateGlobalSetsBtn').addEventListener('click', () => {
                    this.updateGlobalSets();
                });

                // 全局集合区域的导出规则按钮
                document.getElementById('exportRulesFromGlobalBtn').addEventListener('click', async () => {
                    await this.exportRules();
                });

                // 全局集合区域的导入规则按钮
                document.getElementById('importRulesFromGlobalBtn').addEventListener('click', () => {
                    this.importRules();
                });

                // 详细帮助按钮
                document.getElementById('detailedHelpBtn').addEventListener('click', () => {
                    this.showDetailedHelp();
                });

            }

            saveRule() {
                const ruleText = document.getElementById('ruleEditor').value.trim();

                if (!ruleText) {
                    this.showMessage('请输入规则内容', 'warning');
                    return;
                }

                // 检查规则名称是否以#开头
                const lines = ruleText.split('\n');
                const nameMatch = lines[0].match(/^#(.+)$/);
                if (!nameMatch) {
                    this.showMessage('规则名称必须以#开头', 'error');
                    return;
                }

                try {
                    console.log('[DEBUG] 开始保存规则，规则文本:', ruleText);

                    // 直接解析规则文本（注释已包含在文本中）
                    console.log('[DEBUG] 调用 parseRule 方法');
                    const rule = this.ruleEngine.parseRule(ruleText);
                    console.log('[DEBUG] parseRule 成功，解析结果:', rule);

                    // 检查规则冲突
                    console.log('[DEBUG] 开始检查规则冲突');
                    const conflicts = this.checkRuleConflicts(rule);
                    console.log('[DEBUG] 规则冲突检查完成，冲突数量:', conflicts.length);
                    if (conflicts.length > 0) {
                        const conflictMsg = `检测到规则冲突:\n${conflicts.join('\n')}`;
                        if (!confirm(`${conflictMsg}\n\n是否仍要保存此规则？`)) {
                            return;
                        }
                    }

                    console.log('[DEBUG] 调用 saveRule 方法保存规则');
                    this.ruleEngine.saveRule(rule);
                    console.log('[DEBUG] 规则保存成功，开始刷新界面');
                    this.loadSavedRules();
                    document.getElementById('ruleEditor').value = '';

                    this.showMessage(`规则 "${rule.name}" 保存成功`, 'success');
                    console.log('[DEBUG] 规则保存流程完成');

                } catch (error) {
                    console.error('[ERROR] 规则保存错误:', error);
                    console.error('[ERROR] 错误堆栈:', error.stack);
                    this.showMessage(`规则保存失败: ${error.message}`, 'error');
                }
            }

            testRule() {
                const ruleText = document.getElementById('ruleEditor').value.trim();

                if (!ruleText) {
                    this.showMessage('请输入规则内容', 'warning');
                    return;
                }

                try {
                    const rule = this.ruleEngine.parseRule(ruleText);

                    const testWords = [
                        // CVC 模式
                        'cat', 'dog', 'big', 'run', 'sit', 'hot',
                        // CVCE 模式
                        'cake', 'bike', 'home', 'cute', 'make', 'time',
                        // 双辅音开头
                        'black', 'green', 'smart', 'strong', 'place', 'train',
                        // 长单词（10字母内）
                        'beautiful', 'important', 'different', 'wonderful', 'education', 'computer',
                        // 带词根词缀
                        'unhappy', 'teacher', 'helpful', 'quickly'
                    ];
                    const testResults = [];

                    for (const word of testWords) {
                        const matches = this.ruleEngine.matchesRule(word, rule);
                        testResults.push(`${word}: ${matches ? '✓' : '✗'}`);
                    }

                    // 将结果按4列排列显示
                    const columns = 4;
                    const rows = Math.ceil(testResults.length / columns);
                    let formattedResults = '测试结果:\n\n';

                    for (let row = 0; row < rows; row++) {
                        const rowItems = [];
                        for (let col = 0; col < columns; col++) {
                            const index = row + col * rows;
                            if (index < testResults.length) {
                                // 格式化每个结果，确保对齐
                                const result = testResults[index];
                                const paddedResult = result.padEnd(15, ' ');
                                rowItems.push(paddedResult);
                            }
                        }
                        formattedResults += rowItems.join('  ') + '\n';
                    }

                    alert(formattedResults);

                } catch (error) {
                    console.error('规则测试错误:', error);
                    this.showMessage(`规则测试失败: ${error.message}`, 'error');
                }
            }

            formatRule() {
                const ruleText = document.getElementById('ruleEditor').value.trim();
                if (!ruleText) return;

                // 格式化规则：不添加空行，保持紧凑格式
                const lines = ruleText.split('\n');
                const formattedLines = [];

                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed) { // 只保留非空行
                        formattedLines.push(trimmed);
                    }
                }

                document.getElementById('ruleEditor').value = formattedLines.join('\n');
            }

            // 插入非操作符


            loadSavedRules() {
                const container = document.getElementById('savedRulesContainer');
                let ruleNames = this.ruleEngine.getRuleNames();

                if (ruleNames.length === 0) {
                    container.className = 'saved-rules-container empty';
                    container.innerHTML = '<div style="color: #a0aec0; font-size: 16px; font-weight: 500;">暂无保存的规则</div>';
                    return;
                }

                container.className = 'saved-rules-container';

                // 加载规则顺序配置
                this.loadRuleOrder();

                // 清理不存在的规则
                this.cleanupNonExistentRules(ruleNames);

                // 按照保存的顺序排序规则
                ruleNames = this.sortRulesByOrder(ruleNames);

                let html = '<div class="rule-tree">';



                // 渲染所有规则
                ruleNames.forEach(ruleName => {
                    const rule = this.ruleEngine.getRule(ruleName);
                    if (rule) {
                        html += this.createRuleItemHTML(ruleName, rule);
                    }
                });

                html += '</div>';
                container.innerHTML = html;

                // 只在第一次加载时添加拖拽排序功能
                if (!container.hasAttribute('data-drag-initialized')) {
                    this.initializeDragAndDrop(container);
                    container.setAttribute('data-drag-initialized', 'true');
                }

                // 动态添加最后一个规则的下边线
                this.addLastRuleBorder();

                // 恢复规则展开/收缩状态
                this.restoreSavedRuleStates();

                // 更新收缩展开全部按钮的文本
                updateToggleAllSavedButtonText();
            }

            // 动态添加最后一个规则的下边线
            addLastRuleBorder() {
                const ruleTree = document.querySelector('.rule-tree');
                if (!ruleTree) return;

                // 移除之前添加的样式
                const existingStyles = ruleTree.querySelectorAll('.last-rule-border');
                existingStyles.forEach(el => el.classList.remove('last-rule-border'));

                // 找到所有的rule-item-content元素
                const allContents = ruleTree.querySelectorAll('.rule-item-content');
                if (allContents.length === 0) return;

                // 获取最后一个content元素
                const lastContent = allContents[allContents.length - 1];

                // 添加特殊类名和样式
                lastContent.classList.add('last-rule-border');
                lastContent.style.borderBottom = '2px solid #e2e8f0';
                lastContent.style.borderLeft = '2px solid #e2e8f0';
                lastContent.style.borderRight = '2px solid #e2e8f0';
            }

            editRule(ruleName) {
                const rule = this.ruleEngine.getRule(ruleName);
                if (!rule) return;

                let ruleText = `#${rule.name}`;

                if (rule.localSets.size > 0) {
                    for (const [setName, setValues] of rule.localSets) {
                        const values = Array.from(setValues).join(',');
                        ruleText += `\n${setName}=={${values}}`;
                    }
                }

                ruleText += `\n${rule.specificRule}`;

                if (rule.displayRule) {
                    ruleText += `\n${rule.displayRule}`;
                }

                // 如果有注释，将注释添加到规则文本中
                if (rule.comment) {
                    const lines = ruleText.split('\n');
                    // 在规则名称后插入注释行
                    lines.splice(1, 0, `//${rule.comment}`);
                    ruleText = lines.join('\n');
                }

                // 填入完整的规则文本（包含注释）
                document.getElementById('ruleEditor').value = ruleText;
                document.getElementById('ruleEditor').focus();
            }

            deleteRule(ruleName) {
                if (confirm(`确定要删除规则 "${ruleName}" 吗？`)) {
                    this.ruleEngine.deleteRule(ruleName);
                    this.loadSavedRules();
                    this.showMessage(`规则 "${ruleName}" 已删除`, 'success');
                }
            }

            // 移动规则到最前
            moveRuleToFirst(ruleName) {
                // 从当前位置移除规则
                this.ruleOrder = this.ruleOrder.filter(name => name !== ruleName);
                // 添加到最前面
                this.ruleOrder.unshift(ruleName);
                // 保存顺序并重新加载
                this.saveRuleOrder();
                this.loadSavedRules();
                this.showMessage(`规则 "${ruleName}" 已移动到最前`, 'success');
            }

            // 移动规则到最后
            moveRuleToLast(ruleName) {
                // 从当前位置移除规则
                this.ruleOrder = this.ruleOrder.filter(name => name !== ruleName);
                // 添加到最后面
                this.ruleOrder.push(ruleName);
                // 保存顺序并重新加载
                this.saveRuleOrder();
                this.loadSavedRules();
                this.showMessage(`规则 "${ruleName}" 已移动到最后`, 'success');
            }

            showMessage(message, type = 'info') {
                const messageContainer = document.getElementById('messageContainer');

                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                messageDiv.textContent = message;

                messageContainer.appendChild(messageDiv);

                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, 5000);
            }

            // 按名称分组规则
            // groupRulesByName方法已删除，避免与手动分组功能冲突

            // 创建规则项HTML
            createRuleItemHTML(ruleName, rule) {
                const ruleText = this.formatRuleText(rule);
                const commentText = rule.comment ? rule.comment : '';

                return `
                    <div class="rule-item collapsed" data-rule-id="${ruleName}">
                        <div class="rule-item-header" draggable="true" data-rule-name="${ruleName}" onclick="ruleManager.toggleRuleExpansion('${ruleName}')">
                            <div class="rule-item-main">
                                <span class="drag-handle" onclick="event.stopPropagation()">⋮⋮</span>
                                <span class="rule-item-name">${ruleName}</span>
                                ${commentText ? `<span class="rule-item-comment">// ${commentText}</span>` : ''}
                            </div>
                            <div class="rule-item-actions" onclick="event.stopPropagation()">
                                <span class="rule-item-expand-icon" onclick="ruleManager.toggleRuleExpansion('${ruleName}')"></span>
                                <button class="btn-icon" onclick="ruleManager.moveRuleToFirst('${ruleName}')" title="移动到最前">⤴️</button>
                                <button class="btn-icon" onclick="ruleManager.moveRuleToLast('${ruleName}')" title="移动到最后">⤵️</button>
                                <button class="btn-icon" onclick="ruleManager.editRule('${ruleName}')" title="编辑规则">✏️</button>
                                <button class="btn-icon" onclick="ruleManager.deleteRule('${ruleName}')" title="删除规则">🗑️</button>
                            </div>
                        </div>
                        <div class="rule-item-content">${ruleText}</div>
                    </div>
                `;
            }

            // 重构规则文本
            reconstructRuleText(rule) {
                let parts = [`#${rule.name}`];

                // 添加局部集合定义
                if (rule.localSets && rule.localSets.size > 0) {
                    for (const [setName, setValues] of rule.localSets) {
                        const values = Array.isArray(setValues) ? setValues : Array.from(setValues);
                        parts.push(`${setName}=={${values.join(',')}}`);
                    }
                }

                // 添加筛选规则
                if (rule.specificRule) {
                    parts.push(rule.specificRule);
                }

                // 添加排序规则
                if (rule.displayRule) {
                    parts.push(rule.displayRule);
                } else {
                    parts.push('@');
                }

                return parts.join(' | ');
            }

            // 格式化规则文本用于展示
            formatRuleText(rule) {
                let lines = [];

                // 规则名称
                lines.push(`# ${rule.name}`);

                // 注释
                if (rule.comment) {
                    lines.push(`// ${rule.comment}`);
                }

                // 局部集合定义
                if (rule.localSets && rule.localSets.size > 0) {
                    lines.push('');
                    lines.push('# 局部集合定义:');
                    for (const [setName, setValues] of rule.localSets) {
                        const values = Array.isArray(setValues) ? setValues : Array.from(setValues);
                        lines.push(`${setName} == {${values.join(', ')}}`);
                    }
                }

                // 筛选规则
                if (rule.specificRule) {
                    lines.push('');
                    lines.push('# 筛选规则:');
                    lines.push(rule.specificRule);
                }

                // 排序规则
                lines.push('');
                lines.push('# 排序规则:');
                lines.push(rule.displayRule || '@');

                return lines.join('\n');
            }

            // 切换规则展开状态
            toggleRuleExpansion(ruleName) {
                const ruleItem = document.querySelector(`[data-rule-id="${ruleName}"]`);
                if (ruleItem) {
                    if (ruleItem.classList.contains('collapsed')) {
                        ruleItem.classList.remove('collapsed');
                        ruleItem.classList.add('expanded');
                    } else {
                        ruleItem.classList.remove('expanded');
                        ruleItem.classList.add('collapsed');
                    }
                    // 图标旋转由CSS控制，无需手动设置文本

                    // 保存展开/收缩状态
                    const savedRuleStates = JSON.parse(localStorage.getItem('savedRuleStates') || '{}');
                    savedRuleStates[ruleName] = ruleItem.classList.contains('collapsed');
                    localStorage.setItem('savedRuleStates', JSON.stringify(savedRuleStates));

                    // 更新收缩展开全部按钮的文本
                    updateToggleAllSavedButtonText();
                }
            }

            // 恢复规则展开/收缩状态
            restoreSavedRuleStates() {
                const savedRuleStates = JSON.parse(localStorage.getItem('savedRuleStates') || '{}');
                const ruleItems = document.querySelectorAll('.rule-item');

                ruleItems.forEach(item => {
                    const ruleId = item.dataset.ruleId;
                    if (!ruleId) return;

                    const isCollapsed = savedRuleStates[ruleId];
                    if (isCollapsed !== undefined) {
                        if (isCollapsed) {
                            item.classList.remove('expanded');
                            item.classList.add('collapsed');
                        } else {
                            item.classList.remove('collapsed');
                            item.classList.add('expanded');
                        }
                        // 图标旋转由CSS控制，无需手动设置文本
                    }
                });
            }

            // 保存规则排序到本地存储
            saveRuleOrder() {
                const container = document.getElementById('savedRulesContainer');
                const ruleHeaders = container.querySelectorAll('.rule-item-header');
                const ruleOrder = Array.from(ruleHeaders).map(item => item.dataset.ruleName);
                localStorage.setItem('ruleOrder', JSON.stringify(ruleOrder));
            }

            // 从本地存储加载规则排序
            loadRuleOrder() {
                const savedOrder = localStorage.getItem('ruleOrder');
                if (savedOrder) {
                    try {
                        return JSON.parse(savedOrder);
                    } catch (e) {
                        console.warn('Failed to parse saved rule order:', e);
                    }
                }
                return [];
            }

            // 应用规则排序
            applyRuleOrder(rules) {
                const savedOrder = this.loadRuleOrder();
                if (savedOrder.length === 0) {
                    return rules;
                }

                const orderedRules = {};
                const unorderedRules = {};

                // 分离已排序和未排序的规则
                for (const [name, rule] of Object.entries(rules)) {
                    if (savedOrder.includes(name)) {
                        orderedRules[name] = rule;
                    } else {
                        unorderedRules[name] = rule;
                    }
                }

                // 按保存的顺序重新排列
                const result = {};
                for (const name of savedOrder) {
                    if (orderedRules[name]) {
                        result[name] = orderedRules[name];
                    }
                }

                // 添加新的未排序规则到末尾
                for (const [name, rule] of Object.entries(unorderedRules)) {
                    result[name] = rule;
                }

                return result;
            }

            // 更新全局集合
            updateGlobalSets() {
                const globalSetsText = document.getElementById('globalSetsEditor').value.trim();

                if (!globalSetsText) {
                    this.showMessage('请输入全局集合定义', 'warning');
                    return;
                }

                try {
                    // 解析全局集合定义
                    const lines = globalSetsText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                    const newGlobalSets = new Map();
                    const errorLines = [];

                    for (const line of lines) {
                        // 检查是否使用了单等号而非双等号
                        if (line.includes('=') && !line.includes('==') && line.includes('{')) {
                            errorLines.push(`集合定义需要使用双等号(==): ${line}`);
                            continue;
                        }

                        if (line.includes('==')) {
                            const [setName, setDef] = line.split('==');
                            const cleanSetName = setName.trim();

                            // 验证集合名称
                            if (cleanSetName.length === 1) {
                                // 单字母集合名必须是大写
                                if (!/^[A-Z]$/.test(cleanSetName)) {
                                    throw new Error(`单字母集合名 "${cleanSetName}" 必须是大写字母`);
                                }
                            } else {
                                // 多字母集合名在引用时需要用括号
                                console.warn(`集合名称 "${cleanSetName}" 长度超过1个字符，在引用时请使用括号：(${cleanSetName})`);
                            }

                            const setValues = this.parseSetValues(setDef.trim());
                            newGlobalSets.set(cleanSetName, setValues);
                        }
                    }

                    // 如果有错误行，显示错误并终止更新
                    if (errorLines.length > 0) {
                        throw new Error(`存在格式错误的集合定义:\n${errorLines.join('\n')}`);
                    }

                    // 更新RuleEngine中的全局集合
                    this.ruleEngine.updateGlobalSets(newGlobalSets);

                    // 保存到本地存储
                    const globalSetsData = {};
                    for (const [setName, setValues] of newGlobalSets) {
                        globalSetsData[setName] = Array.from(setValues);
                    }
                    localStorage.setItem('globalSets', JSON.stringify(globalSetsData));

                    // 刷新编辑器内容，显示去重后的集合
                    this.refreshGlobalSetsEditor();

                    this.showMessage('全局集合更新成功', 'success');

                } catch (error) {
                    console.error('全局集合更新错误:', error);
                    this.showMessage(`全局集合更新失败: ${error.message}`, 'error');
                }
            }

            // 解析集合值
            parseSetValues(setDef) {
                if (setDef.startsWith('{') && setDef.endsWith('}')) {
                    const content = setDef.slice(1, -1);
                    return new Set(content.split(',').map(item => item.trim()).filter(item => item.length > 0));
                }
                throw new Error(`集合定义格式错误: ${setDef}`);
            }

            // 初始化拖拽排序
            initializeDragAndDrop(container) {
                let draggedElement = null;

                container.addEventListener('dragstart', (e) => {
                    // 检查是否是从rule-item-header或其子元素（如拖拽句柄）开始拖拽
                    const headerElement = e.target.closest('.rule-item-header');

                    if (headerElement) {
                        draggedElement = headerElement;
                        headerElement.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/html', headerElement.outerHTML);
                    }
                });

                container.addEventListener('dragend', (e) => {
                    // 检查是否是从rule-item-header或其子元素结束拖拽
                    const headerElement = e.target.closest('.rule-item-header');

                    if (headerElement) {
                        headerElement.classList.remove('dragging');
                        // 清除所有拖拽指示器
                        container.querySelectorAll('.drag-over').forEach(el => {
                            el.classList.remove('drag-over');
                        });

                        draggedElement = null;
                    }
                });

                container.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    // 清除之前的指示器
                    container.querySelectorAll('.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });

                    if (draggedElement) {
                        // 简化的规则项拖拽逻辑
                        const afterElement = this.getDragAfterElement(container, e.clientY);
                        if (afterElement) {
                            afterElement.classList.add('drag-over');
                        }
                    }
                });

                container.addEventListener('drop', (e) => {
                    e.preventDefault();

                    if (draggedElement) {
                        const afterElement = this.getDragAfterElement(container, e.clientY);

                        // 获取拖拽元素所在的rule-item容器
                        const draggedRuleItem = draggedElement.closest('.rule-item');
                        const draggedRuleName = draggedElement.dataset.ruleName;

                        if (draggedRuleItem && draggedRuleName) {
                            // 简化的拖拽处理逻辑
                            if (afterElement) {
                                const afterRuleItem = afterElement.closest('.rule-item');
                                if (afterRuleItem) {
                                    // 在目标元素之前插入
                                    const targetContainer = afterRuleItem.parentNode;
                                    if (targetContainer && targetContainer.contains(draggedRuleItem)) {
                                        targetContainer.insertBefore(draggedRuleItem, afterRuleItem);
                                        // 更新规则顺序
                                        this.updateRuleOrder();
                                        this.showMessage('规则位置已更新', 'success');
                                    }
                                }
                            } else {
                                // 移动到末尾
                                const targetContainer = draggedRuleItem.parentNode;
                                if (targetContainer) {
                                    targetContainer.appendChild(draggedRuleItem);
                                    // 更新规则顺序
                                    this.updateRuleOrder();
                                    this.showMessage('规则位置已更新', 'success');
                                }
                            }
                        }

                        // 清除拖拽指示器
                        container.querySelectorAll('.drag-over').forEach(el => {
                            el.classList.remove('drag-over');
                        });
                    }
                });

                container.addEventListener('dragleave', (e) => {
                    // 当拖拽离开容器时清除指示器
                    if (!container.contains(e.relatedTarget)) {
                        container.querySelectorAll('.drag-over').forEach(el => {
                            el.classList.remove('drag-over');
                        });
                    }
                });
            }

            // 获取拖拽后的位置
            getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.rule-item-header:not(.dragging)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;

                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }



            // 更新规则顺序
            updateRuleOrder() {
                const container = document.querySelector('.saved-rules-container');
                if (!container) return;

                // 获取所有规则项
                const ruleItems = [...container.querySelectorAll('.rule-item')];

                // 提取规则名称
                const newOrder = ruleItems.map(item => {
                    const header = item.querySelector('.rule-item-header[data-rule-name]');
                    return header ? header.getAttribute('data-rule-name') : null;
                }).filter(name => name !== null);

                // 更新规则顺序
                this.ruleOrder = newOrder;
                this.saveRuleOrder();
            }



            // 分组管理功能
            // 保存规则顺序配置
            saveRuleOrder() {
                localStorage.setItem('ruleOrder', JSON.stringify(this.ruleOrder));
            }

            // 加载规则顺序配置
            loadRuleOrder() {
                const savedOrder = localStorage.getItem('ruleOrder');
                if (savedOrder) {
                    this.ruleOrder = JSON.parse(savedOrder);
                } else {
                    this.ruleOrder = [];
                }
            }

            // 按照保存的顺序排序规则
            sortRulesByOrder(ruleNames) {
                const orderedRules = [];
                const unorderedRules = [...ruleNames];

                // 先添加已排序的规则
                this.ruleOrder.forEach(ruleName => {
                    const index = unorderedRules.indexOf(ruleName);
                    if (index !== -1) {
                        orderedRules.push(ruleName);
                        unorderedRules.splice(index, 1);
                    }
                });

                // 再添加新的未排序规则
                orderedRules.push(...unorderedRules);

                // 更新规则顺序
                this.ruleOrder = orderedRules;
                this.saveRuleOrder();

                return orderedRules;
            }





            // 清理不存在的规则
            cleanupNonExistentRules(ruleNames) {
                this.ruleOrder = this.ruleOrder.filter(ruleName => ruleNames.includes(ruleName));
            }

            // 检查规则冲突
            checkRuleConflicts(newRule) {
                const conflicts = [];
                const existingRules = this.ruleEngine.getRuleNames();

                // 检查名称冲突
                if (existingRules.includes(newRule.name)) {
                    conflicts.push(`规则名称 "${newRule.name}" 已存在`);
                }

                // 检查集合定义冲突
                for (const [setName, setValues] of newRule.localSets) {
                    for (const existingRuleName of existingRules) {
                        const existingRule = this.ruleEngine.getRule(existingRuleName);
                        if (existingRule.localSets.has(setName)) {
                            const existingValues = existingRule.localSets.get(setName);
                            const newValues = Array.from(setValues).sort();
                            const oldValues = Array.from(existingValues).sort();

                            if (JSON.stringify(newValues) !== JSON.stringify(oldValues)) {
                                conflicts.push(`集合 "${setName}" 在规则 "${existingRuleName}" 中有不同定义`);
                            }
                        }
                    }
                }

                return conflicts;
            }

            // 清除所有已保存的规则
            clearAllRules() {
                if (confirm('确定要清除所有已保存的规则吗？此操作不可撤销！')) {
                    // 清除RuleEngine中的所有规则
                    let ruleNames = this.ruleEngine.getRuleNames();
                    ruleNames.forEach(ruleName => {
                        this.ruleEngine.deleteRule(ruleName);
                    });

                    // 清除本地存储中的规则数据
                    localStorage.removeItem('wordFilterRules');
                    localStorage.removeItem('ruleOrder');

                    // 刷新显示
                    this.loadSavedRules();

                    this.showMessage('所有规则已清除', 'success');
                }
            }

            // 显示详细帮助
            showDetailedHelp() {
                window.open('syntax-help.html', '_blank');
            }

            // 获取所有全局集合
            getAllGlobalSets() {
                // 直接从RuleEngine获取真正的全局集合
                return this.ruleEngine.getGlobalSets();
            }

            // 刷新全局集合编辑器内容
            refreshGlobalSetsEditor() {
                const globalSetsEditor = document.getElementById('globalSetsEditor');
                const savedGlobalSets = JSON.parse(localStorage.getItem('globalSets') || '{}');

                let editorContent = '';
                for (const [setName, setValues] of Object.entries(savedGlobalSets)) {
                    if (Array.isArray(setValues)) {
                        editorContent += `${setName}=={${setValues.join(',')}}\n`;
                    }
                }

                // 如果没有保存的全局集合，使用默认值
                if (!editorContent.trim()) {
                    editorContent = 'C=={b,c,d,f,g,h,j,k,l,m,n,p,q,r,s,t,v,w,x,y,z}\nV=={a,e,i,o,u}\nL=={a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
                }

                globalSetsEditor.value = editorContent.trim();
            }

            /**
             * 导出规则到文件
             */
            async exportRules() {
                try {
                    // 按照当前排序顺序获取规则
                    const orderedRules = this.getOrderedRulesForExport();
                    // 临时保存当前规则到ruleEngine，以便导出时包含全局集合
                    const originalRules = this.ruleEngine.rules;
                    this.ruleEngine.rules = orderedRules;

                    const success = await this.ruleEngine.exportRulesToFile();

                    // 恢复原始规则
                    this.ruleEngine.rules = originalRules;

                    if (success) {
                        this.showMessage('规则导出成功！', 'success');
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        // 用户取消操作，不显示任何消息
                        return;
                    }
                    console.error('导出规则失败:', error);
                    this.showMessage('导出规则失败: ' + error.message, 'error');
                }
            }

            /**
             * 按照当前显示顺序获取规则用于导出
             */
            getOrderedRulesForExport() {
                const container = document.getElementById('savedRulesContainer');
                const ruleHeaders = container.querySelectorAll('.rule-item-header');
                const orderedRules = new Map();

                // 按照当前显示顺序添加规则
                Array.from(ruleHeaders).forEach(header => {
                    const ruleName = header.dataset.ruleName;
                    const rule = this.ruleEngine.getRule(ruleName);
                    if (rule) {
                        orderedRules.set(ruleName, rule);
                    }
                });

                return orderedRules;
            }

            /**
             * 从文件导入规则
             */
            importRules() {
                try {
                    this.ruleEngine.importRulesFromFile();

                    // 监听规则更新事件
                    window.addEventListener('rulesUpdated', () => {
                        this.loadSavedRules();
                        this.showMessage('规则导入成功！', 'success');
                    }, { once: true });

                    // 监听全局集合更新事件
                    window.addEventListener('globalSetsUpdated', () => {
                        this.refreshGlobalSetsEditor();
                    }, { once: true });
                } catch (error) {
                    console.error('导入规则失败:', error);
                    this.showMessage('导入规则失败: ' + error.message, 'error');
                }
            }

            /**
             * 加载内置示例
             */
            loadExamples() {
                // 示例已在HTML中静态定义，此方法用于动态加载或更新示例
                console.log('示例已加载');
            }

            /**
             * 应用示例到编辑器
             * @param {string} rule - 规则内容
             */
            applyExample(rule) {
                const ruleEditor = document.getElementById('ruleEditor');
                if (ruleEditor) {
                    ruleEditor.value = rule;
                    this.updatePreview();
                }
            }

            /**
             * 更新预览面板
             */
            updatePreview() {
                // 实时预览功能，可以在这里添加规则预览逻辑
                const ruleText = document.getElementById('ruleEditor').value.trim();
                if (ruleText) {
                    try {
                        // 这里可以添加规则预览逻辑
                        console.log('预览更新:', ruleText);
                    } catch (error) {
                        console.error('预览更新失败:', error);
                    }
                }
            }

            /**
             * 显示语法帮助
             */
            showSyntaxHelp() {
                window.open('syntax-help.html', '_blank');
            }

            /**
             * 切换面板显示
             * @param {string} panel - 面板名称
             */
            togglePanel(panel) {
                const panelElement = document.querySelector(`.${panel}-panel`);
                if (panelElement) {
                    panelElement.classList.toggle('hidden');
                }
            }
        } // RuleManagerApp 类结束

        // 初始化应用
        let ruleManager;
        let isNarrowScreen = false;

        document.addEventListener('DOMContentLoaded', () => {
            ruleManager = new RuleManagerApp();
            window.ruleManager = ruleManager; // 使ruleManager全局可访问

            // 恢复示例的展开/收缩状态
            restoreExampleStates();

            // 初始化响应式监听
            handleResponsiveExamples();
            window.addEventListener('resize', handleResponsiveExamples);

            // 页面加载完成后添加最后一个规则的边框
            setTimeout(() => {
                ruleManager.addLastRuleBorder();
            }, 500);
        });

        // 处理响应式示例收缩/展开
        function handleResponsiveExamples() {
            const currentIsNarrow = window.innerWidth <= 768;

            // 从宽屏切换到窄屏时自动收缩
            if (!isNarrowScreen && currentIsNarrow) {
                collapseAllExamples();
            }
            // 从窄屏切换到宽屏时自动展开
            else if (isNarrowScreen && !currentIsNarrow) {
                expandAllExamples();
            }

            isNarrowScreen = currentIsNarrow;
        }

        // 收缩所有示例（不保存状态）
        function collapseAllExamples() {
            const exampleSections = document.querySelectorAll('.example-section');

            exampleSections.forEach(section => {
                section.classList.add('collapsed');
            });

            // 更新按钮文本
            updateToggleAllButtonText();
        }

        // 展开所有示例（不保存状态）
        function expandAllExamples() {
            const exampleSections = document.querySelectorAll('.example-section');

            exampleSections.forEach(section => {
                section.classList.remove('collapsed');
            });

            // 更新按钮文本
            updateToggleAllButtonText();
        }

        // 全局收缩/展开函数
        function toggleExample(titleElement) {
            const exampleSection = titleElement.parentElement;
            exampleSection.classList.toggle('collapsed');

            // 保存展开/收缩状态到localStorage
            const titleText = titleElement.textContent.trim();
            const isCollapsed = exampleSection.classList.contains('collapsed');
            const exampleStates = JSON.parse(localStorage.getItem('exampleStates') || '{}');
            exampleStates[titleText] = isCollapsed;
            localStorage.setItem('exampleStates', JSON.stringify(exampleStates));

            // 更新收缩/展开全部按钮的文本
            updateToggleAllButtonText();
        }

        // 恢复示例的展开/收缩状态
        function restoreExampleStates() {
            const exampleStates = JSON.parse(localStorage.getItem('exampleStates') || '{}');
            const exampleSections = document.querySelectorAll('.example-section');

            exampleSections.forEach(section => {
                const titleElement = section.querySelector('.example-title');
                const titleText = titleElement.textContent.trim();

                if (exampleStates[titleText]) {
                    section.classList.add('collapsed');
                }
            });

            // 更新按钮文本
            updateToggleAllButtonText();
        }

        // 收缩/展开全部示例
        function toggleAllExamples() {
            const exampleSections = document.querySelectorAll('.example-section');
            const toggleBtn = document.querySelector('.toggle-all-btn .toggle-all-text');

            // 检查当前状态：如果所有示例都是收缩的，则展开全部；否则收缩全部
            const allCollapsed = Array.from(exampleSections).every(section =>
                section.classList.contains('collapsed')
            );

            const exampleStates = {};

            exampleSections.forEach(section => {
                const titleElement = section.querySelector('.example-title');
                const titleText = titleElement.textContent.trim();

                if (allCollapsed) {
                    // 展开全部
                    section.classList.remove('collapsed');
                    exampleStates[titleText] = false;
                } else {
                    // 收缩全部
                    section.classList.add('collapsed');
                    exampleStates[titleText] = true;
                }
            });

            // 保存状态
            localStorage.setItem('exampleStates', JSON.stringify(exampleStates));

            // 更新按钮文本
            updateToggleAllButtonText();
        }

        // 更新收缩/展开全部按钮的文本
        function updateToggleAllButtonText() {
            const exampleSections = document.querySelectorAll('.example-section');
            const toggleBtn = document.querySelector('.examples-header .btn-outline .toggle-all-text');

            if (!toggleBtn) return;

            const allCollapsed = Array.from(exampleSections).every(section =>
                section.classList.contains('collapsed')
            );

            toggleBtn.textContent = allCollapsed ? '➕ 展开全部示例' : '➖ 收缩全部示例';
        }

        // 收缩/展开全部已保存规则
        function toggleAllSavedRules() {
            const ruleItems = document.querySelectorAll('.rule-item');
            const toggleBtn = document.querySelector('.toggle-all-saved-text');

            if (ruleItems.length === 0) return;

            // 检查当前状态：如果所有规则都是收缩的，则展开全部；否则收缩全部
            const allCollapsed = Array.from(ruleItems).every(item =>
                item.classList.contains('collapsed')
            );

            const savedRuleStates = {};

            ruleItems.forEach(item => {
                const ruleId = item.dataset.ruleId;
                if (!ruleId) return;

                if (allCollapsed) {
                    // 展开全部
                    item.classList.remove('collapsed');
                    item.classList.add('expanded');
                    savedRuleStates[ruleId] = false;
                } else {
                    // 收缩全部
                    item.classList.remove('expanded');
                    item.classList.add('collapsed');
                    savedRuleStates[ruleId] = true;
                }
            });

            // 保存状态
            localStorage.setItem('savedRuleStates', JSON.stringify(savedRuleStates));

            // 更新按钮文本
            updateToggleAllSavedButtonText();
        }

        // 更新已保存规则收缩/展开全部按钮的文本
        function updateToggleAllSavedButtonText() {
            const ruleItems = document.querySelectorAll('.rule-item');
            const toggleBtn = document.querySelector('.saved-rules-header .btn-outline .toggle-all-saved-text');

            if (!toggleBtn) return;

            if (ruleItems.length === 0) {
                toggleBtn.textContent = '➖ 收缩全部规则';
                return;
            }

            const allCollapsed = Array.from(ruleItems).every(item =>
                item.classList.contains('collapsed')
            );

            toggleBtn.textContent = allCollapsed ? '➕ 展开全部规则' : '➖ 收缩全部规则';
        }

        // 全局复制函数
        function copyExample(button) {
            const codeBlock = button.parentElement;

            // 克隆代码块以避免修改原始内容
            const clonedBlock = codeBlock.cloneNode(true);

            // 从克隆的块中移除复制按钮
            const clonedButton = clonedBlock.querySelector('button');
            if (clonedButton) {
                clonedButton.remove();
            }

            // 获取纯文本内容
            const textToCopy = clonedBlock.textContent.trim();

            if (!textToCopy) {
                button.textContent = '无内容';
                setTimeout(() => {
                    button.textContent = '复制';
                }, 2000);
                return;
            }

            // 尝试使用现代 Clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    button.textContent = '已复制';
                    button.style.background = '#48bb78';
                    setTimeout(() => {
                        button.textContent = '复制';
                        button.style.background = '#4a5568';
                    }, 2000);
                }).catch(err => {
                    console.error('复制失败:', err);
                    fallbackCopy(textToCopy, button);
                });
            } else {
                // 降级到传统方法
                fallbackCopy(textToCopy, button);
            }
        }

        function fallbackCopy(text, button) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
                button.textContent = '已复制';
                button.style.background = '#48bb78';
            } catch (err) {
                console.error('复制失败:', err);
                button.textContent = '复制失败';
            }

            document.body.removeChild(textArea);
            setTimeout(() => {
                button.textContent = '复制';
                button.style.background = '#4a5568';
            }, 2000);
        }
    </script>
</body>

</html>